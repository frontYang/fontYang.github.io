<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[遇到过的面试题收集]]></title>
    <url>%2F2018%2F05%2F05%2Finterview%2F</url>
    <content type="text"><![CDATA[2018/05/28某公司写出以下控制台输出结果 console.log(1 + 2 + ‘3’)：33 console.log(‘3’ + 2 + 1)：321 console.log(+ ‘3’ + 2 + 1)：6 console.log(1 + + ‘2’ + 3)：6 console.log(‘A’ - ‘B’ + ‘C’)：NaNC console.log(0 &amp;&amp; 2 || 1)：1 var a = 0.1, b = a+++a, c = a–+b; console.log(a, b, c)：0.10000000000000009 1.2000000000000002 2.3000000000000003 将数组 var a = [1, 2, 3] 变成数组 [4, 3, 2, 1],下面方法正确的是(多选) AC A a.reverse().unshift(4) B a.push(4).reverse() C a.push(4);a.reverse() D a.splice(3,1,4).reverse() 目前http2协议已经逐渐普及到日常服务器中，以下对于http2协议描述的正确的是（多选）ABCD A 所有http请求都建立在一个tcp请求上，实现多路复用 B 可以给请求添加优先级 C 服务器主动推送 sever push D http2 的头部会减小，从而减小流量传输 下列哪种方式可以在不改变原来数组的情况，靠背出数组到b，且满足 b!= a,例如数组a为[1,2,3]（多选）BCDA let b = aB let b = a.slice()C let b = a.splice(0,0)D let b = a.concat() 写出三种css水平垂直居中的方式123&lt;div class="box"&gt; &lt;span&gt;垂直居中&lt;/span&gt;&lt;/div&gt; 方案一：table-cell 12345.box&#123; display: table-cell; vertical-align: middle; text-align: center;&#125; 方案二：display:flex12345.box&#123; display: flex; justify-content:center; align-items:Center;&#125; 方案三：绝对定位和负边距1234567891011.box&#123;position:relative;&#125;.box span&#123; position: absolute; width:100px; height: 50px; top:50%; left:50%; margin-left:-50px; margin-top:-25px; text-align: center;&#125; 方案四：绝对定位和012345678.box span&#123; position: absolute; top:50%; left:50%; width:100%; transform:translate(-50%,-50%); text-align: center;&#125; 方案五：translate12345678.box span&#123; position: absolute; top:50%; left:50%; width:100%; transform:translate2d(-50%,-50%); text-align: center;&#125; 方案六：display:inline-block12345678910111213141516.box&#123; text-align:center; font-size:0;&#125;.box span&#123; vertical-align:middle; display:inline-block; font-size:16px;&#125;.box:after&#123; content:''; width:0; height:100%; display:inline-block; vertical-align:middle;&#125; 方案七：display:flex和margin:auto12345.box&#123; display: flex; text-align: center;&#125;.box span&#123;margin: auto;&#125; 方案八：display:-webkit-box1234567.box&#123; display: -webkit-box; -webkit-box-pack:center; -webkit-box-align:center; -webkit-box-orient: vertical; text-align: center&#125; 根据自己的理解，写一个闭包1234567891011function foo() &#123; var num = 123; function fn() &#123; return num;// &#125; return fn;&#125;var m=foo();var f=m();console.log(f);//输出的值为123，这样就可以访问到函数内部变量num。 小程序怎么页面传参？你写过哪些小程序自定义组件，或用过哪些官方组件？传递方式：组件：1&lt;navigator url="component-pages/wx-go-bring-params/index?param=xxxx"&gt;&lt;/navigator&gt; or API：123456789101112 wx.navigateTo(&#123; url:'component-pages/wx-go-bring-params/index?param=xxxx', success: function(res)&#123; // success &#125;, fail: function() &#123; // fail &#125;, complete: function() &#123; // complete &#125;&#125;) 获取方式：123onLoad:function(options)&#123; console.log(options.param)&#125; 在node下，以下执行结果以及原因1234567891011121314151617181920212223242526272829const lilei = &#123; name: 'aaa', sayName: function()&#123; setTimeout(function()&#123; console.log(this.name) &#125;, 500) &#125;, sayName1: function()&#123; var that = this setTimeout(function()&#123; console.log(that.name) &#125;, 1000) &#125;, sayName2: function()&#123; setTimeout(() =&gt; &#123; console.log(this.name) &#125;, 1500) &#125;, sayName3: () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(this.name) &#125;, 2000) &#125;&#125;;lilei.sayName(); // undefinedlilei.sayName1(); // aaalilei.sayName2(); // aaalilei.sayName3(); // undefined 使用vue/react或者你熟悉的框架，编写一个简单的Todolist组件，可以不考虑样式，点击添加后，可以把input内容加入到列表中，列表中事项点击后可以删除1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="newItem"&gt;&lt;span v-on:click="addItem"&gt;增加&lt;/span&gt; &lt;ul&gt; &lt;li v-for="(item, index) in items" v-on:click="removeItem(index)"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', data()&#123; return &#123; items: [], newItem: '' &#125; &#125;, methods: &#123; addItem()&#123; this.items.push(this.newItem) this.newItem = '' &#125;, removeItem(index)&#123; this.items.splice(index, 1) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 2018/05/23某公司请写出让下方DIV水平居中的样式&lt;div style=&quot;width: 500px; height: 100px; position: absolute;&quot;&gt;&lt;/div&gt;12345678910111213141516171819/*水平居中*/div&#123; left: 50%; margin-left:-250px;&#125;/*水平垂直居中 一*/div&#123; left: 50%; top:50%; margin-left:-250px; margin-top: -50px;&#125;div&#123; left: 50%; top:50%; transform:translate(-50%, -50%, 0)&#125; &lt;span&gt;和&lt;p&gt;在默认样式上有什么区别 前者：行内元素，一般放文字等 后者：块级元素，指一个段落 解释下列的css选择器 li .c , li.d li .c&gt;d li .c + .d 请写出下方HTML代码默认状态下输出后的表现方式 X&lt;SUP&gt;2&lt;SUP&gt; X2 &lt;p&gt;test &lt;mark&gt;text&lt;/mark&gt;&lt;/p&gt; test text &lt;details&gt;test &lt;summary&gt;text&lt;/summary&gt;&lt;/details&gt; test text 请写出一个input并满足以下条件：HTML5日期选择器，点击选择后结果只显示年和月，且只能选择今天的日期&lt;input type=&quot;month&quot; value=&quot;2015-09&quot;/&gt; $(function(){}())和(function(){}())的区别 前者： Jquery语法的匿名函数，用于存放操作DOM对象的代码，执行其中代码时DOM对象已存在；（通过这样就可以在页面加载完成时通过ajax再异步加载一些数据） 后者： 用于存放开发插件的代码，执行其中代码时DOM不一定存在;（用于在内容加载时或加载前加载） mouseenter 和 mouseover的区别 前者：只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。对应mouseleave 后者：不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。对应mouseout setTimeout和setInterval的区别 前者：在执行时,是在载入后延迟指定时间后,去执行一次表达式,次数是一次， 后者：从载入后,每隔指定的时间就执行一次表达式 写出以下代码输出的结果12345678910111213141516function act(i)&#123; var s; s = i++; i++; return cal(s+i);&#125;function cal(i)&#123; var s; s = i--; s++; return s;&#125;alert(act(1))// 答案：5 口述Jq中Deferred对象的应用实例（描述应该什么时候使用，会有什么效果） 详解：http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html deferred对象就是jQuery的回调函数解决方案 deferred对象有三种执行状态—-未完成，已完成和已失败，如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数 2018/05/05某公司手写一个ajax12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function ajax(opts)&#123; //实例化XMLHttpRequest，如果兼容ie7-需要加 ActiveXObject判断 let createXHR = function()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; // ie7 + return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != 'undefined')&#123; ie7 - let versions = &#123; 'MSXML2.XMLHTTP.6.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP' &#125; for(let verson of versons)&#123; try&#123; new ActiveXObject(verson); arguments.callee.activeXString = verson; break; &#125;catch&#123; // 跳过 &#125; &#125; return new ActiveXObject(arguments.callee.activeXString)； &#125;else&#123; throw new Error('没有可用的XHR对象') &#125; &#125; // 字符串编码 let addURLParam = function(data)&#123; let query = []; for (let key in data) &#123; query.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key])); &#125; return query.join('&amp;'); &#125; let xhr = createXHR(); //onreadystate事件 xhr.onreadystate = function()&#123; if(xhr.readyState == 4)&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; // 请求成功,获取请求主体 // xhr.requestText opts.success &amp;&amp; opts.success(xhr.requestText) &#125;else&#123; // 请求失败 &#125; &#125; &#125; xhr.open(opts.type, opts.url, true) if(opts.type == 'POST')&#123; let query = addURLParam(opts.data) xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded') xhr.send(query) &#125;else&#123; xhr.send(null) &#125;&#125; 作用域12345678910111213141516var name = 'aaa'var obj = &#123; name: 'bbb', prop: &#123; name: 'ccc', getName: function()&#123; return this.name &#125; &#125;&#125;console.log(obj.prop.getName()) // cccvar test = obj.prop.getNameconsole.log(test()) // aaa 闭包123456789// 假设有四个按钮var button = document.getElementsByTagName('button')for (var i = 0; i &lt; button.length; i++) &#123; button[i].addEventListener('click', function()&#123; console.log(i) &#125;)&#125;无论点击哪个按钮，最后都是输出4 选中table tr 偶数行（不知道是css还是js） css: table tr:nth-child(even) &gt; td jq: $(&#39;table tr:even&#39;) 原生js 12345678let trs = document.querySelectorAll('#tableid tr')for(let i = 0; i &lt; trs.length; i++)&#123; if(i % 2 == 1)&#123; // 奇数 &#125;else &#123; // 偶数 &#125;&#125; 外边距叠加 当两个或更多垂直外边距相遇时，它们将形成一个外边距，这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。 get和post的区别 get 用来获取数据。从服务器获取数据（也可以上传数据，参数就是），效率较高 能够被缓存 不安全。get的所有参数全部包装在URL中，明文显示，且服务器的访问日志会记录 数据量限制：不能的浏览器和服务器不同，一般限制在2-8k之间，常见的是1k以内 post 用来提交数据。但可以向服务器发送数据和下载数据，效率不如GET 不会被缓存 相对安全。post的url中只有资源路径，不会包含参数，参数封装在二进制的数据体中，服务器也不会记录参数。所有涉及用户隐私的数据都要用POST传输 post方法提交的数据比较大，大小靠服务器的设定值限定 图片按需怎么实现 需要按需加载的img标签，图片的真实地址保存到自定的属性里，如’data-src’,src属性用一张1像素透明的图片 把某范围内的img标签元素保存到数组里面 定义一个方法：遍历数据元素，然后判断某元素的offsetTop是否在滚动的可视范围，如果在，交互图片的属性，然后删除这个元素，那么下次遍历就不存在了 给window对象添加scroll与resize事件 用户有可能快速拉滚动条，这样会导致事件的频繁触发，所以需要添加setTimeout 代码来自：https://www.cnblogs.com/focuslgy/p/3194502.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class LazyImage &#123; constructor(opt) &#123; this.init(opt) &#125; init(opt)&#123; this.setOptions(opt); this.load(); this.fnLoad = this.bind(this,this.load); this.addHandler(window,'scroll',this.fnLoad); this.addHandler(window,'resize',this.fnLoad); &#125; setOptions(opt)&#123; this.holderSrc = opt.holderSrc || 'data-src'; this.wrapId = opt.wrapId; this.imgList = []; this.timer = null; var targets = null; if (document.querySelectorAll) &#123; targets = document.querySelectorAll("#" + this.wrapId + " img") &#125; else &#123; targets = document.getElementById(this.wrapId).getElementsByTagName("img") &#125; var n = 0, len = targets.length; // 把元素存到数组里 for(;n&lt;len;n++)&#123; if(targets[n].getAttribute(this.holderSrc))&#123; this.imgList.push(targets[n]); &#125; &#125; &#125; load()&#123; // 全部加装，解除事件 if(this.imgList.length == 0)&#123; this.removeHandler(window,'scroll',this.fnLoad); this.removeHandler(window,'resize',this.fnLoad); return &#125; var st = document.body.scrollTop || document.documentElement.scrollTop, clientH = document.documentElement.clientHeight, scrollArea = st + clientH; for(var n=0;n&lt;this.imgList.length;n++)&#123; var offsetTop = this.imgList[n].getBoundingClientRect().top+st, imgH = this.imgList[n].clientHeight; if( scrollArea&gt;(offsetTop-200)&amp;&amp;(imgH+offsetTop)&gt;st )&#123; var _src = this.imgList[n].getAttribute(this.holderSrc); this.imgList[n].setAttribute('src',_src); this.imgList.splice(n,1);//删除已经加载完的元素 n--; &#125; &#125; &#125; bind(obj,fn)&#123; return () =&gt; &#123; if(this.timer) clearTimeout(this.timer); this.timer = setTimeout(function()&#123; fn.apply(obj,arguments); &#125;,300); &#125; &#125; addHandler(node,type,fn)&#123; if(node.addEventListener)&#123; node.addEventListener(type,fn,false); &#125;else if(node.attachEvent)&#123; node.attachEvent('on'+type,function()&#123; fn.apply(node,arguments); &#125;); &#125;else&#123; node['on' + type] = fn &#125; &#125; removeHandler(node, type, fn) &#123; if (node.addEventListener) &#123; node.removeEventListener(type, fn, false); &#125; else if(node.attachEvent) &#123; node.detachEvent("on" + type, fn); &#125;else&#123; node['on' + type] = null &#125; &#125;&#125; 实现拖拽的基本思路 两种方式 使用html的新特性dragable，但是由于在火狐浏览器上dragable每拖拽一次会打开一个新的标签，尝试阻止默认行为和冒泡都无法解决 使用js监听鼠标三个事件（onmousedown,onmousemove,onmouseup），配合节点操作来实现, 根据鼠标的x,y坐标的变化来改变被拖拽的元素top和left。同时需要判断鼠标的状态是否为按下状态，是否是在可拖拽的元素上按下的 在允许拖拽的节点元素上，使用on来监听mousedown(按下鼠标按钮)事件，获取节点坐标 监听mousemove(鼠标移动)事件，修改节点的坐标，实现节点跟随鼠标的效果 监听mouseup(放开鼠标按钮)事件，更新原节点坐标，拖拽完成。 1234567891011121314鼠标在元素上按下的时候&#123; 拖拽状态 = 1 记录下鼠标的x和y坐标 记录下元素的x和y坐标 &#125; 鼠标在元素上移动的时候&#123; 如果拖拽状态是0就什么也不做。 如果拖拽状态是1，那么 元素y = 现在鼠标y - 原来鼠标y + 原来元素y 元素x = 现在鼠标x - 原来鼠标x + 原来元素x &#125; 鼠标在任何时候放开的时候&#123; 拖拽状态 = 0&#125; 怎么理解原型和原型链 每个对象都会在其内部初始化一个属性，就是prototype(原型),当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 instance.constructor.prototype = instance._proto_ js对象是通过引用来传递的，创建的每一个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有，就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。 其他经典面试题(待续。。。) 参考自https://juejin.im/entry/5533d3a9e4b078a907047186 范围（Scope）1234567891011121314151617181920212223(function()&#123; var a = b = 5&#125;)()console.log(b) // 5// a是通过var声明的，是这个函数的本地变量// b没有被声明，属于这个函数的全局变量(function()&#123; 'use strict'; var a = b = 5&#125;)()console.log(b) // b is not defined// 在严格模式下，会报出未捕获引用错误：b没有定义// 在严格模式下，如果这个是预期的行为，则需要明确的引用全局变量(function()&#123; 'use strict' var a = window.b = 5;&#125;)()console.log(b) // 5 创建”原生（native）”方法在String对象上定义一个repeatify函数。这个函数接受一个整数参数，来明确字符串需要重复几次。这个函数要求字符串重复指定的次数。举个例子： 12console.log('hello'.repeatify(3));// 打印出hellohellohello 123456789Srting.prototype.repeatify = String.prototype.repeatify || function(times)&#123; var str = &apos;&apos;; for(var i = 0; i &lt; items; i++)&#123; str += this; &#125; return str;&#125; 变量提升（Hoisting）12345678910111213141516171819202122232425262728function test()&#123; var a; function foo()&#123; return 2 &#125; console.log(a) console.log(foo()) a = 1&#125;test() // undefined 2// 变量和函数都被提升了，与以下代码相同function test()&#123; var a; function foo()&#123; return 2 &#125; console.log(a) console.log(foo()) a = 1&#125;test() this 在javascript中是如何工作的1234567891011121314151617181920var fullname = 'John Doe'var obj = &#123; fullname: 'Colin Ihrig', prop: &#123; fullname: 'Aurelio De Rosa', getFullname: function()&#123; return this.fullname &#125; &#125;&#125;console.log(obj.prop.getFullname()) // Aurelio De Rosavar test = obj.prop.getFullname;console.log(test()) // John Doe// 在js中，一个函数的语境，也就是this关键字的引用，依赖于函数是符合调用的，不是如何定义的// 在第一个console.log()调用中， getFullname()是作为obj.prop的函数被调用的。因此，这里的语境指向后者并且函数返回对象的 fullname属性。相反，当 getFullname() 被指定为test的变量，那个语境指向全局对象(window)。因为test相当于设置为全局对象的属性。因为这个原因，函数返回window的一个fullname属性，这在这个案例中是在代码片段中第一行设置的。 call()和apply()修复上一个问题，让最后一个console.log()打印出Aurelio De Rosa1234567console.log(test.call(obj.prop))// orvar test = obj.prop.getFullname();console.log(test) // Aurelio De Rosa]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax基础学习]]></title>
    <url>%2F2018%2F05%2F05%2Fajax-base%2F</url>
    <content type="text"><![CDATA[创建XMLHttpRequest对象： 123456789101112131415161718192021222324252627282930313233/** * 检测原生XHR是否存在 * 是：返回XHR实例 * 否：检测ActiveX对象 * 如果两种对象都不存在，抛出错误 */function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; // 兼容ie7+ return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject != 'undefined')&#123; // 兼容ie7- if(typeof arguments.callee.activeXString != 'string')&#123; let versions = &#123; 'MSXML2.XMLHTTP.6.0', 'MSXML2.XMLHttp.3.0', 'MSXML2.XMLHttp' &#125;; for(let version of versions)&#123; try &#123; new ActiveXObject(version); arguments.callee.activeXString = version; break; &#125; catch &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;else&#123; throw new Error('没有可用的XHR对象.') &#125;&#125; XHR用法 123456789101112131415161718192021222324252627282930let XHR = createXHR();/** * readyState: * 0： 未初始化。尚未调用open() * 1： 启动。已经调用open()，但尚未调用send()方法 * 2： 发送。已经调用send()方法，但尚未接收到响应 * 3： 接收。已经接收到部分响应数据 * 4： 完成。已经接收到全部响应数据，而且已经可以在客户端使用了 * * status： * 200： OK * 404：未找到页面 */XHR.onreadystatechange = function()&#123; if(XHR.readyState == 4)&#123; if((XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; 300) || XHR.status == 304)&#123; &#125;else &#123; //success &#125; &#125;else &#123; // 请求失败 &#125;&#125;;XHR.open('get', 'example.txt', true);XHR.send(null);//XHR.abort()//终止请求 HTTP头部信息 Accept：浏览器能够处理的内容类型 Accept-Charset：浏览器能够处理的字符集 Accept-Encoding：浏览器能够处理的压缩编码 Accept-Language：浏览器当前设置的语言 Connection：浏览器与服务器之间连接的类型 Cookie：当前页面设置的任何Cookie Host：发出请求的页面所在域 Referer：发出请求的页面的URI User-Agent：浏览器的用户代理字符串 GET请求 用于向服务器查询某些信息，必要时，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。对于XHR而言，位于传入open()法的URL末尾的查询字符串的每个参数的名称和值都必须使用encodeURIComponent()进行编码，然后才能放到URL末尾，而且所有的名-值对都必须由&amp;分割123456789101112let url = 'example.php'url = addURLParam(url, 'name', 'dsagd')url = addURLParam(url, 'value', 'dsagd')XHR.open('get', url, true)function addURLParam(url, name, value)&#123; url += (url.indexOf('?') == -1 ? '?' : '&amp;'); url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url;&#125; POST请求 通常用于向服务器发送应该被保存的数据。post请求把数据作为请求的主体提交，请求的主体可以包含非常多的数据，而且格式不限12// post请求必须在调用open()方法之后且调用send方法之前调用setRequestHeader()XHR.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;) XMLHttpRequest 2 级 FormData 用来解决现代web应用中频繁使用表单数据的序列化，不必明确的在XHR对象上设置请求头部。XHR对象能够识别传入的数据类型是FormData实例，并配置适当的头部信息。12345678910111213141516let data = new FormData();data.append('name', 'nicho');let XHR = createXHR();XHR.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if((XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; 300) || XHR.status == 304)&#123; // XHR.responseText &#125;else &#123; // 失败 &#125; &#125;&#125;XHR.open('post', 'postexample.php', true);let form = document.getElementById('user-info');XHR.send(new FormData(form)) 超时设定 表示请求在等待多少毫秒之后就终止。在给timeout设置一个数值后，如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序123456789101112131415161718192021let XHR = createXHR();XHR.readystatechange = function()&#123; if(XHR.readyState == 4)&#123; try()&#123; if((XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; =300) || XHR.status == 304)&#123; // XHR.responseText &#125;else &#123; // 失败 &#125; &#125;catch&#123; //假设由ontimeout事件程序处理 &#125; &#125;&#125;XHR.open('get', 'timeout.php', true)XHR.timeout = 1000; // 仅适用于ie8+XHR.ontimeout = function()&#123; // 请求没有立即返回。&#125;XHR.send(null) overrideMimeType() 用于重写XHR响应的MIME类型 此方法必须在send()之前，才能保证重写响应的MIME类型1234let XHR = createXHR();XHR.open('get', 'test.php', true);XHR.overrideMimeType('text/xml'); // 强迫XHR对象将响应当做XML而非纯文本来处理XHR.send(null); 进度事件 所有事件 loadstart：在接收到响应数据的第一个字节时触发 progress：在接收响应期间持续不断地触发 error：在请求发生错误时触发 abort：在因为调用abort()方法而终止连接时触发 load：在接收到完整的响应数据时触发 loadend：在通信完成或者触发error、abort或load事件后触发 load事件 只要浏览器接收到服务器的响应，不管其状态如何，都会触发load事件。1234567891011let XHR = createXHR();XHR.onload = function()&#123; if((XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; 300) || XHR.status == 304)&#123; // XHR.responseText &#125;else &#123; // 失败 &#125;&#125;;XHR.open('get', 'test.php', true);XHR.send(null); progress事件 必须在调用open之前添加此事件123456789101112131415161718let XHR = createXHR();XHR.onload = function(event)&#123; if((XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; 300) || XHR.status == 304)&#123; // XHR.responseText &#125;else &#123; // 失败 &#125;&#125;XHR.onprogress = function(event)&#123; let divStatus = document.getElementById('status'); if(event.lengthComputable)&#123; // 信息进度是否可用 divStatus.innerHTML = '预期字节数' + event.totalSize + '，接收到' + event.position + '字节数' &#125;&#125;XHR.open('get', 'test.php', true)XHR.send(null) 跨源资源共享（Cross-Origin Resource Sharing） IE对Cors的实现 IE引入了XDR（XDomainRequest），与XHR类似，但能实现安全可靠的跨域通信， XDR与XHR的不同之处： cookie不会随请求发送，也不会随响应返回 只能设置请求头部信息中的Content-Type字段 不能访问响应头部信息 只支持GET和POST open()只需两个参数：请求类型和URL1234567891011121314151617181920212223let xdr = new XDomainRequest();xdr.onload = function()&#123; //xdr.responseText&#125;xdr.onerror = function()&#123; // 出错&#125;xdr.timeout = 1000xdr.ontimeout = function()&#123; // 请求超时&#125;// GET//xdr.open('get', 'test/test/')//xdr.send(null)// POSTxdr.open('post', 'url')xdr.contentType = 'applycation/x-www-from-urlencoded'xdr.send('name1=value1&amp;name2=value2') 其他浏览器对CORS的实现 要请求位于另一个域中的资源，使用标准的XHR对象并且在open()方法中传入绝对URL即可 与XDR不同，通过跨域XHR对象可以访问status和statusText属性，而且还支持同步请求，但为了安全，不能使用setRequestHeader()设置自定义头部，不能发送和接收cookie，调用getAllResponseHeaders()方法总会返回空字符串12345678910111213let xhr = createXHR();xhr.onreadychange = function()&#123; if(xhr.readyState == 4)&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; // xhr.responseText &#125;else &#123; // 失败 &#125; &#125;&#125;xhr.open('get', 'http://url', true)xhr.send(null) Preflighted Requeusts 支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会向服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部 Origin: 与简单的请求相同 Access-Control-Request-Method：请求自身使用的方法 Access-Control-Request-Headers：（可选），自定义的头部信息，多个头部以逗号分隔 发送请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通 Access-Control-Allow-Origin：与简单的请求相同 Access-COntrol-Allow-Methods：允许的方法，多个方法以逗号分隔 Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔 Access-Control-Max-Age：应该将这个Preflight请求缓存多长时间（以秒表示） 带凭据的请求 通过将widthCredentials属性设置为true，可以指定某个请求应该发送凭据，如果服务器接受带凭据的请求，会用下面的HTTP头部来响应 Access-Control-Allow-Credients:true 如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给Javascript，另外服务器还可以在Preflight响应中发送这个HTTP头部，表示允许源发送带凭据的请求 跨浏览器的CORS1234567891011121314151617181920212223function createCORSRequest(method, url)&#123; let xhr = new XMLHttpRequest(); if('WithCreadentials' in xhr)&#123; xhr.open(method, url, true) &#125;else if(typeof XDomainRequest != 'undefined')&#123; xhr = new XDomainRequest(); xhr.open(method, url); &#125;else &#123; xhr = null; &#125; return xhr;&#125;let request = createCORSRequest('get', 'http://sdga');if(request)&#123; request.onload = function()&#123; // request.responseText &#125; request.send()&#125; 其他跨域技术 图像Ping 图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图形Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的12345let img = new Image();img.onload = img.onerror = function()&#123; alert('Done')&#125;img.src = 'http://sdag' JSONP（json width padding） 是通过动态是&lt;script&gt;标签来使用的，使用时可以为src属性指定一个跨域URL 两部分组成： 回调函数：是当响应到来时应该在页面中调用的函数 数据：传入回调函数中的JSON数据 缺点： 从其他域加载代码执行，不安全 要确定JSONP请求是否失败并不容易 123456function handleResponse(data)&#123;&#125;let script = document.createElement('script')script.src = 'http://sagd?callback=handleResponse'document.body.insertBefore(script, document.body.firstChild) 安全 为确保XHR访问的URL安全，通行的做法就是验证发送请求者是否有权限访问相应的资源 要求以SSI连接访问可以通过XHR请求的资源 要求每一次请求都要附带经过相应的算法计算得到的验证码 要求发送POST而不是GET请求——很容易改变（对防范CSRF攻击不起作用） 检查来源URL以确定是否可信——来源记录很容易伪造（对防范CSRF攻击不起作用） 基于cookie信息进行验证——同样很容易伪造（对防范CSRF攻击不起作用）]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试知识点收集]]></title>
    <url>%2F2018%2F04%2F01%2Fbasic%2F</url>
    <content type="text"><![CDATA[HTML篇doctype doctype 是用来告知浏览器的解析器用什么文档标准解析这个文档 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt; HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 link/@import区别 link 属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用 页面被加载的时，link会同时被加载 支持使用js控制DOM去改变样式 @import 是CSS提供的，只能用于加载CSS 页面被加载的时，等到页面被加载完再加载 不支持使用js控制DOM去改变样式 html语义化 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析 Javascript篇 原型/原型链 cookies/sessionStorage/localStorage的区别 cookie cookie是网站为了标示用户身份而存储在用户本地终端上的数据，通常经过加密 cookie数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器之间来回传递 cookie数据大小不能超过4k 设置cookie的过期时间之前一直有效，即使窗口或浏览器关闭 sessionStorage和localStorage 不会自动把数据发给服务器，仅在本地保存 存储大小比cookie大得多，可以达到5M或更大 sessionStorage 数据在当前浏览器窗口关闭后自动删除 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 数组去重 双层循环 1234567891011121314151617181920function unique(array)&#123; // 存储结果 var res = []; for(var i = 0, arrLen = array.length; i &lt; arrLen; i++)&#123; for(var j = 0, resLen = res.length; j &lt; resLen; j++)&#123; if(array[i] == res[j])&#123; break; &#125; &#125; // 如果array[i]是唯一的，那么执行完循环，j等于resLen if(j === resLen)&#123; res.push(array[i]) &#125; &#125; return res;&#125; indexOf 12345678910111213function unique(array)&#123; var res = []; for(var i = 0, len = arr.length; i &lt; len; i++)&#123; var current = array[i]; if(res.indexOf(current) === -1)&#123; res.push(current); &#125; &#125; return res;&#125; 排序后去重 1234567891011121314151617function unique(array)&#123; var res = []; var sortedArray = array.concat().sort(); var seen; for(var i = 0, len = sortedArray.length; i &lt; len; i++)&#123; // 如果是第一个元素或者相邻的元素不相同 if(!i || seen !== sortedArray[i])&#123; res.push(sortedArray[i]); &#125; seen = sortedArray[i]; &#125; return res;&#125; 深入 123456789101112131415161718function unique(array, isSorted)&#123; var res = []; var seen = []; for(var i = 0, len = array.length; i &lt; len; i++)&#123; var value = array[i]; if(isSorted)&#123; if(!i || seen !== value)&#123; res.push(value) &#125; seen = value; &#125;else if(res.indexOf(value) === -1)&#123; res.push(value); &#125; return res &#125;&#125; 优化 123456789101112131415161718192021222324252627// 迭代function unique(array, isSorted, iteratee)&#123; var res = []; var seen = []; for(var i = 0, len = array.length; i &lt; len; i++)&#123; var value = array[i]; var computed = iteratee ? iteratee(value, i, array) : value; if(isSorted)&#123; if(!i || seen !== value)&#123; res.push(value); &#125; seen = value; &#125;else if(iteratee)&#123; if(seen.indexOf(computed) === -1)&#123; seen.push(computed); res.push(value); &#125; &#125;else if(res.indexOf(value) === -1)&#123; res.push(value); &#125; &#125; return res;&#125; fiter(ES5) 1234567function unique(array)&#123; var res = array.filter(function(item, index. array)&#123; return array.indexOf(item) === index; &#125;) return res;&#125; 待续。。。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas学习与实践]]></title>
    <url>%2F2018%2F03%2F31%2Fcanvas%2F</url>
    <content type="text"><![CDATA[一、canvas 与 SVG的区别 canvas和svg之间一个重要的区别：使用canvas来绘制图形是通过调用它提供的方法，而使用svg绘制图形是通过构建一棵XML元素树来实现 二、canvas基础 note: (摘自《javascript权威指南》) 1、定义上下文对象 大部分画布绘制的API都不是在&lt;canvas&gt;元素自身上定义的，而是定义在一个”绘制上下文”对象上，获取该对象可以通过调用画布的getContext()方法。12let canvas = document.getElementById('canvas');let ctx = canvas.getContext('2d'); 2、 绘制线段和填充多边形 图形属性 fillStyle：填充颜色/渐变/图案等样式 font：绘制文本css样式 globalAlpha：绘制像素时要添加的透明度 (?) globalCompositeOperation：如何合并新的像素点和下面的像素点 (?) lineCap：如何渲染线段末端 lineJoin：如何渲染顶点 lineWidth：外框线的宽度 miterLimit：紧急斜接顶点的最大长度 (?) textAlign：文本水平对齐方式 textBaseline：文本垂直对齐方式 shadowBlur：阴影的清晰或模糊程度 shadowColor：下拉阴影的颜色 shadowOffsetX：阴影的水平偏移量 shadowOffsetY：阴影的垂直偏移量 strokeStyle：勾勒线段时的颜色/渐变/图案等样式 案例: 12345678910111213141516171819202122232425262728293031323334353637// 定义一个以(x, y)为中心， 半径为r的规则n边形// 每个顶点都是均匀分布在圆周上// 将第一个顶点放置在最上面，或者指定一定角度// 除非最后一个参数是true，否则顺时针旋转function polygon(c, n, x, y, r, angle, counterclockwise)&#123; angle = angle || 0; counterclockwise = counterclockwise || false; ctx.moveTo(x + r * Math.sin(angle), // 从第一个顶点开始一条新的路径 y - r * Math.cos(angle)); // 使用三角形计算位置 let delta = 2 * Math.PI / n; // 两个顶点之间的夹角 for(let i = 1; i &lt; n; i ++)&#123; // 循环剩余的每个顶点 angle += counterclockwise ? -delta : delta; // 调整角度 ctx.lineTo(x + r * Math.sin(angle), // 以下个顶点为端点添加线段 y - r * Math.cos(angle)); &#125; ctx.closePath(); // 将最后一个顶点和起点连接起来&#125;ctx.beginPath();let x = 50;polygon(ctx, 3, x, 70, 50); // 三角形polygon(ctx, 4, x + x * 2, 60, 50, Math.PI / 4); // 正方形polygon(ctx, 5, x + x * 3, 55, 50); // 五边形polygon(ctx, 6, x + x * 4, 53, 50, Math.PI / 6); // 六边形polygon(ctx, 4, x + x * 5, 53, 20, Math.PI / 4, true); // 六边形中的小正方形ctx.fillStyle() = '#ccc'; // 内部填充颜色ctx.stockStyle = '#oo8'; // 边框颜色ctx.lineWidth = 5; // 边框跨度ctx.fill(); // 填充ctx.stroke(); // 勾勒外边框 (效果图) 3、画布的尺寸与坐标 (注：图片来自MDN) 4、坐标系变换（占坑）5、绘制和填充曲线 arc(ox, oy, radius, startRadian, endRadian, [true | false])： 在当前子路径中添加一条弧 参数： ox: 圆心x坐标 oy: 圆心y坐标 radius: 半径 startRadian: 起始弧 endRadian: 结束弧 true: 逆时针 | false: 顺时针 arcTo(x1, y1, x2, y2, radius):绘制一条直线和一段圆弧 x1: 起点x坐标 y1: 起点y坐标 x2: 终点x坐标 y2: 终点y坐标 radius:半径 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)：实现在当前子路径中添加一个新的点，并利用三次贝塞尔曲线将它和当前点相连(?) cp1x: 第一个控制点x坐标 cp1y: 第一个控制点y坐标 cp2x: 第二个控制点x坐标 cp2y: 第二个控制点y坐标 x: 结束点x坐标 y: 结束点y坐标 quadraticCurveTo(cpx, cpy, x, y)：与bezierCurveTo()类似，不同的是它使用的是二次贝塞尔曲线而不是三次贝塞尔曲线并且只有一个控制点(?) cpx: 控制点x坐标 cpy: 控制点y坐标 x: 结束点x坐标 y: 结束点y坐标 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142// 将角度转化成弧度制function rads(x)&#123; return Math.PI * x / 180;&#125;// 圆形ctx.beginPath();ctx.arc(75, 100, 50, 0, rads(360), false); // 圆心位于(75, 100), 半径为50, 从0°到360°顺时针旋转ctx.closePath(); // 闭合// 扇形ctx.moveTo(200, 100);ctx.arc(200, 100, 50, rads(-60), rads(0), false); // 顺时针ctx.closePath(); // 闭合ctx.moveTo(325, 100);ctx.arc(325, 100, 50, rads(-60), rads(0), true); // 逆时针ctx.closePath(); // 闭合// 直线+圆弧ctx.moveTo(450, 50); // 从上边的中点开始ctx.arcTo(500, 50, 500, 150, 30); //添加部分上边和右上角ctx.arcTo(500, 150, 400, 150, 30); // 添加右上角和右下角ctx.arcTo(400, 150, 400, 50, 10); // 添加底边和左下角ctx.arcTo(400, 50, 500, 550, 0); // 添加左边和左上角ctx.closePath(); // 闭合// 二次贝塞尔曲线ctx.moveTo(75, 250)ctx.quadraticCurveTo(100, 200, 175, 250); // 画一条以一直到点(175, 250)结束的曲线ctx.fillRect(100 - 3, 200 - 3, 6, 6); // 标记控制点(100, 200)// 三次贝塞尔曲线ctx.moveTo(200, 250);ctx.bezierCurveTo(220, 220, 280, 280, 300, 250); // 画一条以一直到点(300, 250)结束曲线ctx.fillRect(220 - 3, 220 - 3, 6, 6); // 标记控制点ctx.fillRect(280 - 3, 280 - 3, 6, 6);ctx.fillStyle = '#aaa';ctx.lineWidth = 5;ctx.fill();ctx.stroke(); (效果图) 6、矩形 fillRect(x,y,width,height): 使用当前点的fillStyle来填充指定的矩形 参数: x:矩形左上角的x坐标 y: 矩形左上角的y坐标 width: 矩形的宽度 height: 矩形的高度 strokeRect(x,y,width,height): 使用当前的strokeStyle和其他线段的属性来勾勒指定矩形的外边框，参数与fillRect()相同 clearRect(x,y,width,height): 清除矩形，参数与fillRect()相同 rect(x,y,width,height): 绘制矩形，会对当前路径产生影响，会在指定的矩形添加到当前路径的子路径中，参数与fillRect()相同 7、颜色、透明度、渐变、图案（占坑）8、文本 fillText(text, x, y, [maxWidth])：在画布上绘制填色的文本 参数: text: 文案 x: 开始绘制文本的x坐标(相对于画布) y: 开始绘制文本的y坐标(相对于画布) maxWidth: 可选，允许的最大文本宽度 strokeText(text, x, y, [maxWidth])： 在画布上绘制文本（无填充色），参数与fillText()相同 9、裁剪 clip(): 当调用此方法时，当路径自身就会裁剪到当前裁剪区域中，之后，被裁剪的路径就变成了新的裁剪区域，也就是说，此方法只会缩小裁剪区域，永远不会放大裁剪区域，由于没有提供重置裁剪区域的方法，因此在调用clip()之前通常要调用save()方法，以便于恢复为裁剪区域123456789101112131415161718192021ctx.font = 'bold 60pt san-serif'; // 设置字体ctx.lineWidth = 2; // 线段宽度ctx.strokeStyle = '#000'; // 线段颜色// 勾勒矩形轮廓和文本轮廓ctx.strokeRect(175, 20, 50, 325);ctx.strokeText = ('&lt;canvas&gt;', 15, 330);// note：polygon方法见上面的示例polygon(ctx, 3, 200, 225, 200); // 大三角形polygon(ctx, 3, 200, 225, 100, 0, true); // 小三角形ctx.clip(); // 将该路径定义成裁剪区域ctx.lineWidth = 10; // 另外5个像素的线段被裁剪了ctx.stroke();ctx.fillStyle = '#aaa'; // 填充颜色ctx.fillRect(175, 25, 50, 325); // 填充竖直的条带ctx.fillStyle = '#888'; // 填充颜色ctx.fillText('&lt;canvas&gt;', 15, 330); // 填充文本 (效果图) 10、阴影 shadowOffsetX属性和shadowOffsetY属性总是默认在坐标空间中的度量的，不受rotate()和scale()方法影响。 123456789101112131415// 不明显的阴影ctx.shadowColor = 'rgba(100, 100, 100, .4)'; // 半透明灰色ctx.shadowOffsetX = ctx.shadowOffsetY = 3; // 偏移阴影到右下角部分ctx.shadowBlur = 5; // 柔化阴影的边缘ctx.lineWidth = 10;ctx.strokeStyle = 'blue';ctx.strokeRect(100, 100, 300, 200); // 绘制一个巨型ctx.font = 'Bold 36pt Helvetica';ctx.fillText('Hello World', 115, 225); //绘制文本ctx.shaowOffsetX = ctx.shadowOffsetY = 20;ctx.shadowBlur = 10;ctx.fillStyle = 'red'; // 绘制一个红色的矩形ctx.fillRect(50, 25, 200, 65); // 该红色矩形浮在蓝色方框上面 (效果图) 11、图片 drawImage(): 将源图片(或源图片中的矩形区域中)的像素内容复制到画布上，有需要的时候可以对图片进行缩放和旋转 语法一：drawImage(img,x,y) 语法二：drawImage(img,x,y,width,height) 语法三：drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数说明: img: 图像、画布或视频 sx: 开始剪切的 x 坐标位置 sy: 开始剪切的 y 坐标位置 swidth: 被剪切图像的宽度 sheight: 被剪切图像的高度 x: 在画布上放置图像的 x 坐标位置 y: 在画布上放置图像的 y 坐标位置 width: 要使用的图像的宽度 height: 要使用的图像的高度 案例 12345678910111213ctx.moveTo(5, 5);ctx.lineTo(45, 45);ctx.lineWidth = 8;ctx.lineCap = 'round';ctx.stroke();ctx.translate(50, 100);ctx.rotate(-45 * Math.PI / 180); // 让线段变得更直ctx.scale(10, 10); // 将它放大到能够看到每个像素ctx.drawImage(ctx.canvas, 0, 0, 50, 50, // 源矩形区域 未变换 0, 0, 50, 50) // 目标矩形区域 变换过 (效果图) toDataUrl():画布自身的方法，将画布内容以png图片的形式返回，同时编码成一个字符串数据，用url表示，返回的url可以在&lt;img&gt;元素中使用，同时也可以实现画布静态截图的功能；此方法有一个很重要的安全限制，为了避免跨域的信息泄露，toDataURL()方法无法在非”origin-clean”的&lt;canvas&gt;上使用。123var img = document.createElement('img');img.src = canvas.toDataURL();document.body.appendChild(img); 12、合成（占坑）13、像素操作 getImageData(): 返回 ImageData 对象，该对象拷贝了画布指定矩形的像素数据,同样收同源安全策略的限制 putImageData(): 方法将图像数据（从指定的 ImageData 对象）放回画布上 示例(?)1234567891011121314151617181920212223242526272829303132333435363738// 使用ImageData实现动态模糊// 将矩形区域的像素向右进行涂抹// 来产生动态模糊效果，就好像物体正在从右向左移动// n必须要&gt;= 2， 该值越大，涂抹区域就越大// 矩形是在默认坐标中指定的function smear(c, n, x, y, w, h)&#123; // 获取表示矩形区域内像素的ImageData对象来实现涂抹效果 let pixels = c.getImageData(x, y, w, h); // 就地实现涂抹效果并只需要ImageData对象数据 // 一些图片处理算法要求额外的ImageData对象来存储变换后的像素值 // 如果需要输出缓冲区，可以以如下方式创建一个新的同样尺寸的ImageData对象 let output_pixels = c.createImageData(pixels); // 这些尺寸可能和w和h之类的参数不同，有可能是每个css像素要表示多个设备像素 let width = pixels.width, height = pixels.height; // data变量包含所有原始的像素信息，从左到右， 从上到下 // 每个像素按照RGBA的顺序共占据4个字节 let data = pixels.data; // 每一行的一个像素之后的像素都是通过将其色值替换成其色素值得1/0 + 原色素值的m/n let m = n - 1; for(let row = 0; row.height; row++)&#123; let i = row * width * 4 + 4; for(let col = 1; col &lt;width; col++, i+= 4)&#123; data[i] = (data[i] + data[i - 4] * m) / n; data[i + 1] = (data[i + 1] + data[i - 3] * m) / n; data[i + 2] = (data[i + 2] + data[i - 2] * m) / n; data[i + 3] = (data[i + 3] + data[i - 1] * m) / n; &#125; &#125; // 将涂抹过的图片数据复制回画布相同的位置 c.putImageData(pixels, x, y);&#125; 14、命中检测 isPointInPath(x, y): 确定一个指定的点是否落在(或者在边界上)当前路径中，返回true(落在当前路径中)|false(没落在当前路径中) 示例123456789101112131415161718192021// 如果鼠标事件发生指定的CanvasRenderingContext2D对象的当前路径上则返回truefunction hitpath(context, event)&#123; // 从&lt;canvas&gt;对象中获取&lt;canvas&gt;元素 let canvas = context.canvas; // 获取画布尺寸和位置 let bb = canvas.getBoundingClientRect(); // 将鼠标事件坐标通过转换和缩放变化成画布坐标 let x = (event.clientX - bb.left) * (canvas.width / bb.width); let y = (event.clientY - bb.top) * (canvas.height / bb.height); // 用这些变化后的坐标来调用isPointInPath()方法 return context.isPointInPath(x, y);&#125;canvas.onclick = function()&#123; if(hitpath(this.getContext('2d'), event)&#123; alert('Hit'); &#125;&#125; 以上源码地址(https://github.com/frontYang/study/tree/master/canvas/cases) 三、个人实践1、圆形占比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 绘制圆环占比 */// 圆形占比drawRound(&#123; id: 'j-round-config', data: &#123; name: '配置', width: 66, // 宽 height: 66, // 高 lineWidth: 3, // 边框宽 max: 100, // 满分 // cur: 88, // 当前值 per: 88, // 占比 state: 1 // 1:优秀 2: 良好, 3: 一般, 4:较差 &#125;&#125;)function drawRound(opts)&#123; let canvas = document.getElementById(opts.id); if(!canvas) return; let ctx = canvas.getContext('2d'), data = opts.data, width = data.width * 2, // 宽 height = data.height * 2, // 高 lineWidth = data.lineWidth * 2, // 环宽度 R = width / 2 - lineWidth / 2, // 半径 per = data.per, // 占比 bgColor = '#f4f4f8', // 背景环颜色 curColor = '#3496e9', ox = width / 2, // 圆心 X oy = height / 2; // 圆心 Y canvas.width = width; canvas.height = height; // 清除画布 let clear = function()&#123; ctx.clearRect(0, 0, width, height); &#125;, // 画底层圆弧 drawArcBg = function()&#123; ctx.beginPath(); ctx.lineCap = 'round'; ctx.arc(ox, oy, R, 0, 2 * Math.PI); ctx.lineWidth = lineWidth; ctx.strokeStyle = bgColor; ctx.stroke(); ctx.closePath(); &#125;, // 画高亮圆弧 drawArcCur = function()&#123; let rad = 2 * Math.PI / data.max; ctx.beginPath(); ctx.arc(ox, oy, R, 1.5 * Math.PI, 1.5 * Math.PI + per * rad); // 计算结束点弧度 ctx.lineWidth = lineWidth; ctx.strokeStyle = curColor; ctx.lineCap = 'round'; ctx.stroke(); ctx.closePath(); &#125;, // 填充文案 fillText = function()&#123; ctx.beginPath(); ctx.font = '20px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = '#999'; ctx.fillText(data.name, width / 2, height - 75); ctx.closePath(); ctx.beginPath(); let stateText = '', stateColor = ''; if(data.state == 1)&#123; stateText = '优秀'; // stateColor = '#f94e4e'; &#125;else if(data.state == 2)&#123; stateText = '良好'; // stateColor = '#ff8800'; &#125;else if(data.state == 3)&#123; stateText = '一般'; // stateColor = '#ffbb00'; &#125;else if(data.state == 4)&#123; stateText = '较差'; // stateColor = '#cccccc'; &#125; ctx.font = '26px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = '#333'; ctx.fillStyle = stateColor; ctx.fillText(stateText, width / 2, height - 35); ctx.closePath(); &#125;, draw = function()&#123; clear(); drawArcBg(); drawArcCur(); fillText(); &#125;; draw();&#125; (圆环) 2、仪表盘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// 绘制仪表图drawDashboard(&#123; id: 'j-dashboard', data: &#123; width: 236, // 宽 height: 141, // 高 lineWidth: 16, // 边框宽 max: 100, // 满分 cur: 88, // 当前值 per: 88, // 占比 state: 1 // 1: 烈推荐,2: 值得推荐, 3: 一般推荐, 4:不太推荐 &#125;&#125;)/* 绘制仪表图 */function drawDashboard(opts)&#123; let canvas = document.getElementById(opts.id); if(!canvas) return; let ctx = canvas.getContext('2d'), data = opts.data, width = data.width * 2, // 宽 height = data.height * 2, // 高 lineWidth = data.lineWidth * 2, // 环宽度 R = width / 2 - lineWidth / 2, // 半径 otherHeight = width / 2 - height / 2, // 半圆多余的高度 per = data.per, // 占比 bgColor = '#e6f2fe', // 背景环颜色 curStartColor = '#52bff9', curEndColor = '#0780e1', scaleColor = '#b8deee', // 刻度颜色 ox = R + lineWidth / 2, // 圆心 X oy = height + lineWidth / 2 - otherHeight / 2; // 圆心 Y canvas.width = width; canvas.height = height; // 清除画布 let clear = function()&#123; ctx.clearRect(0, 0, width, height); &#125;, // 画底层圆弧 drawArcBg = function()&#123; ctx.beginPath(); ctx.lineCap = 'round'; ctx.arc(ox, oy, R, 0.8 * Math.PI, 0.2 * Math.PI); // ctx.arc(ox, oy, R, 1 * Math.PI, 0 * Math.PI); ctx.lineWidth = lineWidth; ctx.strokeStyle = bgColor; ctx.stroke(); ctx.closePath(); &#125;, // 画高亮圆弧 drawArcCur = function()&#123; let rad = Math.PI / data.max; ctx.beginPath(); ctx.arc(ox, oy, R, 0.8 * Math.PI, Math.PI + per * rad); // 计算结束点弧度 // ctx.arc(ox, oy, R, 1 * Math.PI, Math.PI + per * rad); // 计算结束点弧度 ctx.lineWidth = lineWidth; ctx.strokeStyle = curEndColor; ctx.lineCap = 'round'; ctx.stroke(); ctx.closePath(); &#125;, // 画刻度 drawArcScale = function()&#123; let scaleLen = 23, // 刻度数 ?? 只画了16个 padding = lineWidth / 2 + 12 * 2 , // 距圆环距离 R1 = (width / 2) - padding, // 半径 smallWidth = 10, // 小刻度宽 largeWidth = 20 // 大刻度宽 for (let i = 1; i &lt;= scaleLen * 2; i++) &#123; ctx.beginPath(); let rad = Math.PI + Math.PI / scaleLen * (i - 1), x1 = ox + Math.sin(rad) * R1, y1 = oy - Math.cos(rad) * R1, x2, y2; ctx.moveTo(x1, y1); if(i == 1 || i == scaleLen * 2) &#123; ctx.strokeStyle = '#000'; &#125;else &#123; ctx.strokeStyle = scaleColor; &#125; ctx.lineWidth = 2; if(i % 2 == 0)&#123; // 偶數 长刻度 x2 = ox + Math.sin(rad) * (R1 - largeWidth); y2 = oy - Math.cos(rad) * (R1 - largeWidth); &#125;else&#123; // 奇数 短刻度 x2 = ox + Math.sin(rad) * (R1 - smallWidth); y2 = oy - Math.cos(rad) * (R1 - smallWidth); &#125; ctx.lineTo(x2 , y2); ctx.stroke(); ctx.closePath(); &#125; &#125;, // 填充文案 fillText = function()&#123; ctx.beginPath(); ctx.font = 'bold 80px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillText(data.cur, width / 2, height - 100); ctx.closePath(); ctx.beginPath(); ctx.font = '24px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = '#999'; ctx.fillText(`满分$&#123;data.max&#125;`, width / 2, height - 60); ctx.closePath(); ctx.beginPath(); let stateText = '', stateColor = ''; if(data.state == 1)&#123; stateText = '强烈推荐'; stateColor = '#f94e4e'; &#125;else if(data.state == 2)&#123; stateText = '值得推荐'; stateColor = '#ff8800'; &#125;else if(data.state == 3)&#123; stateText = '一般推荐'; stateColor = '#ffbb00'; &#125;else if(data.state == 4)&#123; stateText = '不太推荐'; stateColor = '#cccccc'; &#125; ctx.font = '36px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = stateColor; ctx.fillText(stateText, width / 2, height - 15); ctx.closePath(); &#125;, draw = function()&#123; clear(); drawArcBg(); drawArcCur(); drawArcScale(); fillText(); &#125;; draw();&#125; (效果图) 3、折线图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// 画折线图drawLineChart(&#123; id: 'j-chart-line', data: &#123; width: 351, height: 212, xAxis: ['1年', '2年', '3年', '4年', '5年'], //X 轴文案 yAxis: ['100%', '80%', '60%', '40%', '30%', '0%'], // y轴文案 yData: ['80%', '60%', '40%', '20%', '30%'] // y轴数据 &#125;&#125;)/* 绘制折线图 */function drawLineChart(opts)&#123; let canvas = document.getElementById(opts.id) if(!canvas) return; let ctx = canvas.getContext('2d'), data = opts.data, width = data.width * 2, height = data.height * 2, xArr = [], yArr = [], yPerWidth = 82, // y轴文案宽度 yWidth = width - yPerWidth, // y轴宽度 yHeight = 60, // y轴间距 xWidth = yWidth / data.xAxis.length, // 每个 x 宽度 lineColor = '#007adf', // 折线颜色 axisColor = '#eee' // 轴线颜色 // 设置宽高 canvas.width = width; canvas.height = height; ctx.font = '24px Microsoft Yahei'; /** * 画圆点 * @param &#123;object&#125; ctx canvas绘图环境 * @param &#123;object&#125; opt x,y起始点; r半径 */ let drawPoint = function(ctx, opt)&#123; ctx.arc(opt.x, opt.y, opt.r, 0, 2 * Math.PI, Math.PI, false); ctx.fillStyle = opt.color; ctx.fill(); ctx.closePath(); &#125;, /** * 画折线 * @param &#123;object&#125; ctx canvas绘图环境 * @param &#123;object&#125; opt x0,y0起始点; x1,y1结束点 */ drawLine = function(ctx, opt)&#123; ctx.beginPath(); ctx.moveTo(opt.x0, opt.y0); ctx.lineTo(opt.x1, opt.y1); ctx.strokeStyle = opt.color; ctx.stroke(); ctx.closePath(); &#125;, // 画X轴 drawX = function()&#123; ctx.beginPath(); // 第一个刻度 ctx.moveTo(yPerWidth, height - yHeight - 10); ctx.lineTo(yPerWidth, height - yHeight - 20); ctx.textAlign = 'center'; ctx.lineWidth = 2; ctx.strokeStyle = axisColor; // 其余刻度 for (let i = 0; i &lt; data.xAxis.length; i++) &#123; ctx.moveTo(yPerWidth + xWidth * (i + 1), height - yHeight - 10); ctx.lineTo(yPerWidth + xWidth * (i + 1), height - yHeight - 20); ctx.fillText(data.xAxis[i], xWidth * (i + 1) + 24, yHeight * data.yAxis.length + 24); ctx.fill(); ctx.stroke(); ctx.closePath(); &#125; &#125;, // 画Y轴 drawY = function()&#123; ctx.beginPath(); for (let i = 0; i &lt; data.yAxis.length; i++) &#123; ctx.fillText(data.yAxis[i], 0, yHeight * (i + 1), yPerWidth); ctx.moveTo(yPerWidth, yHeight * (i + 1) - 8); ctx.lineTo(width, yHeight * (i + 1) - 8); ctx.lineWidth = 2; ctx.strokeStyle = axisColor; ctx.fill(); ctx.stroke(); ctx.closePath(); &#125; &#125;, drawCurLine = function()&#123; let H = yHeight * 5; let R = 6; ctx.fillStyle = lineColor; ctx.moveTo(yPerWidth, yHeight); for (let i = 0; i &lt; data.yData.length; i++) &#123; let perH = data.yData[i].replace(/%/, '') / 100 * H ctx.beginPath(); ctx.arc(xWidth * (i + 1) - R / 2, H - perH + yHeight - R, R, 0, 2 * Math.PI, false); ctx.fillStyle = lineColor; ctx.fill(); if(i &lt;= data.yData.length - 2)&#123; perH = data.yData[i + 1].replace(/%/, '') / 100 * H; ctx.lineTo(xWidth * (i + 2) - R / 2, H - perH + yHeight - R) &#125; ctx.strokeStyle = lineColor; ctx.stroke(); ctx.closePath(); &#125; &#125;, draw = function()&#123; drawY(); drawX(); drawCurLine(); &#125; draw();&#125; (效果图) 以上源码地址(https://github.com/frontYang/lib/chartUtil)(未完。。。)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp学习笔记]]></title>
    <url>%2F2018%2F03%2F17%2Fgulp%2F</url>
    <content type="text"><![CDATA[一、安装 yarn global add gulp 运行：gulp tast名 项目目录结构(示例) 12345678910111213141516171819202122232425262728293031323334353637383940+ src(项目原目录) * images(图片) - icon(需要生成精灵图的图片) + icon1.png + icon2.png - pic.png * js(页面js) - block(公共js) + common.js + util.js - index.js * css(页面css) - block(公共css) + reset.scss + header.scss - index.scss * components(公共模块) - header.html - footer.html * index.html+ dist(生成目录，不需创建) * images - sprite.png - pic.png * js - block + common.js + util.js - index.js * css - block + reset.css + header.scss + sprites.css - index.css * index.html+ node_modules(node模块，不需创建)+ gulpfile.js(gulp配置js)+ package.json+ yarn.lock 二、部分插件的安装和使用1、browser-sync：自动刷新 安装： yarn add browser-sync123456789const browserSync = require('browser-sync');gulp.task('browserSync', function()&#123; browserSync(&#123; server: &#123; baseDir: 'dist' &#125; &#125;)&#125;) 2、处理css相关插件 安装： yarn add gulp-sass gulp-postcss autoprefixer del-gulpsass-blank-lines123456789101112131415const sass = require('gulp-sass'); // 编译Sassconst postcss = require('gulp-postcss'); // 后处理器const autoprefixer = require('autoprefixer'); // 加前缀，与postcss配合使用const dgbl = require("del-gulpsass-blank-lines"); // 删掉sass空行gulp.task('sass', function()&#123; return gulp.src('src/css/**/*.scss') .pipe(sass(&#123;outputStyle: 'compact'&#125;).on('error', sass.logError)) .pipe(dgbl()) .pipe(postcss([autoprefixer(&#123;browsers: ['last 2 versions', 'Android &gt; 4.4','iOS &gt;= 8', 'Firefox &gt;= 20']&#125;)])) .pipe(gulp.dest('dist/css')) .pipe(browserSync.reload(&#123; // 只有被改变的地方局部刷新 stream: true &#125;))&#125;) 3、gulp-babel：es6转es5 安装： yarn add gulp-babel1234567891011const babel = require('gulp-babel'); // bablegulp.task('babel', function()&#123; return gulp.src('src/js/**/*.js') .pipe(babel(&#123; presets: ['@babel/env'], plugins: ['@babel/transform-runtime'] &#125;)) // .pipe(uglify()) .pipe(gulp.dest('dist/js'))&#125;) 4、处理图片 安装： yarn add gulp-imagemin gulp.spritesmith gulp-cache1234567891011121314151617181920212223242526272829303132333435363738394041const imagemin = require('gulp-imagemin'); // 优化图片const spritesmith = require('gulp.spritesmith'); // 图片精灵const cache = require('gulp-cache'); // 缓存代理任务。，减少图片重复压缩gulp.task('images', function() &#123; return gulp.src('src/images/icon/*.png') // Caching images that ran through imagemin .pipe(cache(imagemin(&#123; interlaced: true, &#125;))) .pipe(spritesmith(&#123; imgName:'images/sprite.png', //合并后大图的名称 cssName:'css/block/sprite.css', padding:2// 每个图片之间的间距，默认为0px // cssTemplate:(data)=&gt;&#123; // 可以自定义输出格式 // // data为对象，保存合成前小图和合成打大图的信息包括小图在大图之中的信息 // let arr = [], // width = data.spritesheet.px.width, // height = data.spritesheet.px.height, // url = data.spritesheet.image // // console.log(data) // data.sprites.forEach(function(sprite) &#123; // arr.push( // '.icon-'+sprite.name+ // '&#123;'+ // 'background: url('+url+') '+ // 'no-repeat '+ // sprite.px.offset_x+' '+sprite.px.offset_y+';'+ // 'background-size: '+ width+' '+height+';'+ // 'width: '+sprite.px.width+';'+ // 'height: '+sprite.px.height+';'+ // '&#125;\n' // ) // &#125;) // // return "@fs:108rem;\n"+arr.join("") // return arr.join('') // &#125; &#125;)) .pipe(gulp.dest('dist/'))&#125;); 5、gulp-content-includer： include 公共模块 安装： yarn add gulp-content-includer1234567891011const contentIncluder = require('gulp-content-includer');gulp.task('concat',function() &#123; gulp.src('src/*.html') .pipe(contentIncluder(&#123; // 可以自定义 includerReg:/&lt;!\-\-\#include\s+virtual="([^"]+)"\-\-&gt;/g &#125;)) .pipe(gulp.dest('dist/'))&#125;);// 可以使用 &lt;!--#include virtual="./components/header.html"--&gt; 方式来引入公共模块 6、清理生成文件 安装： yarn add del12345678910111213const del = require('del'); // 清理生成文件// 删除 除了images/文件夹，dist下的任意文件gulp.task('clean:dist', function() &#123; return del.sync(['dist/**/*', '!dist/images', '!dist/images/**/*']);&#125;);// 在某些时候我们还是需要清除图片，所以clean任务我们还需要保留gulp.task('clean', function() &#123; return del.sync('dist').then(function(cb) &#123; return cache.clearAll(cb); &#125;);&#125;) 7、组合任务 安装： yarn add run-sequence1234567891011121314151617181920212223const runSequence = require('run-sequence'); // 按照指定顺序运行任务// 监听文件，刷新浏览器gulp.task('watch', function() &#123; gulp.watch('src/scss/**/*.scss', ['sass']); gulp.watch('src/**/*.html', browserSync.reload); gulp.watch('src/js/**/*.js', browserSync.reload);&#125;)// 按顺序执行任务，放 [] 内的任务会同时执行gulp.task('build', function(callback) &#123; runSequence( 'clean:dist', ['sass','babel','concat','images'], callback )&#125;)gulp.task('default', function(callback) &#123; runSequence(['sass', 'babel', 'browserSync', 'concat', 'images'], 'watch', callback )&#125;) 参考连接仓库地址]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe跨域问题]]></title>
    <url>%2F2018%2F03%2F11%2Fiframe%2F</url>
    <content type="text"><![CDATA[一、主域相同 子页面和父页面都加上 document.domain = &quot;子页面域名&quot; 二、跨全域高度自适应1、postMessage(不兼容ie8-) 父页面 1234567891011121314&lt;iframe onload="resizeCrossDomainIframe('iframepage', '子页面域名');" src="父页面")function resizeCrossDomainIframe(id, other_domain) &#123; var iframe = document.getElementById(id); window.addEventListener('message', function(event) &#123; if (event.origin !== other_domain) return; // only accept messages from the specified domain if (isNaN(event.data)) return; // only accept something which can be parsed as a number var height = parseInt(event.data) + 32; // add some extra height to avoid scrollbar iframe.height = height + "px"; &#125;, false);&#125; 子页面 1&lt;body onload="parent.postMessage(document.body.scrollHeight, '父页面域名');"&gt; 2、使用代理页面 父页面 1&lt;iframe id="parentPage" name="mainFrame" scrolling="no" src="子页面" frameborder="0" width="100%"&gt;&lt;/iframe&gt; 代理页面(与父页面同域名) 12345678910&lt;script&gt;var b_iframe = window.parent.parent.document.getElementById("parentPage");var hash_url = window.location.hash;if (hash_url.indexOf("#") &gt;= 0) &#123; var hash_width = hash_url.split("#")[1].split("|")[0] + "px"; var hash_height = hash_url.split("#")[1].split("|")[1] + "px"; b_iframe.style.width = hash_width; b_iframe.style.height = hash_height;&#125;&lt;/script&gt; 子页面 123456789&lt;iframe id="agentPage" height="0" width="0" src="中间页面" style="display:none"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt;(function autoHeight() &#123; var b_width = Math.max(document.body.scrollWidth, document.body.clientWidth); var b_height = Math.max(document.body.scrollHeight, document.body.clientHeight); var c_iframe = document.getElementById("agentPage"); c_iframe.src = c_iframe.src + "#" + b_width + "|" + b_height;&#125;)();&lt;/script&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用css收集]]></title>
    <url>%2F2018%2F03%2F11%2Fcss%2F</url>
    <content type="text"><![CDATA[一、 reset 1234567891011121314151617181920212223@charset 'utf-8';@charset "GBK";*&#123;margin:0;padding:0; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-text-size-adjust:none; &#125;*:focus,*:active &#123;outline:none;&#125;html, body &#123; height:100%;&#125;body&#123; width: 100%;font-family: \5FAE\8F6F\96C5\9ED1,\5B8B\4F53;-webkit-user-select:none;&#125;p,a,span,textarea,b,input,dt,dd &#123; color: #666;font-size: 0.9rem;&#125;ul, ol&#123;list-style:none;&#125;img&#123;border:none;&#125;a &#123; text-decoration:none;&#125;textarea &#123;resize:none;&#125;input[type=button],button&#123;text-align: center; background: none; border: 0; outline: none; &#125;input &#123; background: white; border: none; outline: none;&#125;/*占位符颜色*/input::-webkit-input-placeholder, textarea::-webkit-input-placeholder &#123; color:#ccc; &#125;input:-moz-placeholder, textarea:-moz-placeholder &#123; color:#ccc; &#125;input::-moz-placeholder, textarea::-moz-placeholder &#123; color: #ccc; &#125;input:-ms-input-placeholder, textarea:-ms-input-placeholder &#123; color: #ccc; &#125;/*占位符点击消失*/input:focus::-webkit-input-placeholder&#123;text-indent: -999em; z-index: -20; &#125; 二、function1234567891011/* 浮动 */.fl &#123; float: left !important; &#125;.fr &#123; float: right !important; &#125;.clear &#123; clear: both; &#125;/* 功能 */.hide &#123; display:none !important; &#125;/*隐藏*/.ellipsis1 &#123; overflow:hidden;-o-text-overflow:ellipsis;text-overflow:ellipsis;white-space:nowrap;word-break:keep-all; &#125; /* 字数省略 */.ellipsis2 &#123;display: -webkit-box; -webkit-line-clamp:2; overflow: hidden; -webkit-box-orient: vertical; text-overflow: ellipsis;&#125; /* 两行字数省略 */.keep &#123; position:fixed !important;border-bottom: #ccc 1px solid !important; &#125; /*滚动保持*/.mask &#123;display: none;position: fixed;left: 0;z-index: 11;width: 100%; height: 100%;background-color:rgba(0, 0, 0, 0.4);&#125;/*遮罩层*/ 三、skin12345678/* 效果 */.shadow,.all-shadow * &#123;box-shadow: 0 0 .3rem #ddd !important;&#125;.gradient,.all-gradient * &#123;background: -webkit-linear-gradient(top, #fff4f4,#fff);&#125;.radius,.all-radius * &#123; border-radius: .2em;&#125;.left-radius &#123;border-top-left-radius: .2em;border-bottom-left-radius: .2em;&#125;.right-radius &#123;border-top-right-radius: .2em;border-bottom-right-radius: .2em;&#125;.top-radius &#123;border-top-left-radius: .2em;border-top-right-radius: .2em;&#125;.alpha&#123;filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity: 0.5; opacity: 0.5;&#125; 四、arrow12345678910111213141516171819202122232425262728293031323334353637383940414243/* 纯css实现箭头样式 u:上 r:右 d:下 l:左; S*//** * 实心箭头 */.icon-arrA&#123;display: inline-block;/* ie7下需要 加上inline-block 才生效,ie6不支持*/ font-size: 0; line-height: 0; overflow: hidden; &#125;.icon-arrA-u&#123;border-width: 8px; border-style: solid; border-color: transparent transparent #e6e6e6 transparent; &#125;.icon-arrA-d&#123;border-width: 8px; border-style: solid; border-color: #e6e6e6 transparent transparent transparent; &#125;.icon-arrA-l&#123;border-width: 8px; border-style: solid; border-color: transparent #e6e6e6 transparent transparent; &#125;.icon-arrA-r&#123;border-width: 8px; border-style: solid; border-color: transparent transparent transparent #e6e6e6; &#125;/** * 边框箭头 兼容webkit */.icon-arrB&#123;display: inline-block; width: 8px; height: 8px; font-size: 0; overflow: hidden; background-color: transparent; border-width: 2px 2px 0 0; border-style: solid; border-color: #e6e6e6; &#125;.icon-arrB-u&#123;-webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); transform: rotate(-45deg); &#125;.icon-arrB-d&#123;-webkit-transform: rotate(135deg); -moz-transform: rotate(135deg); -ms-transform: rotate(135deg); transform: rotate(135deg); &#125;.icon-arrB-l&#123;-webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); transform: rotate(45deg); &#125;.icon-arrB-r&#123;-webkit-transform: rotate(-135deg); -moz-transform: rotate(-135deg); -ms-transform: rotate(-135deg); transform: rotate(45deg); &#125;/** * 边框箭头：兼容 ie（不包括ie6） */.arr-wrap&#123;display: inline-block; position: relative; &#125;.arr-wrap .icon-arrA&#123;position: absolute; left: 0; &#125;.arr-wrap .s1.icon-arrA-u, .arr-wrap .s1.icon-arrA-r, .arr-wrap .s1.icon-arrA-d, .arr-wrap .s1.icon-arrA-l&#123;z-index: 1; &#125;.arr-wrap .s1.icon-arrA-u, .arr-wrap .s2.icon-arrA-d&#123;top: 2px; &#125;.arr-wrap .s2.icon-arrA-u, .arr-wrap .s1.icon-arrA-d&#123;top: 0; &#125;.arr-wrap .s2.icon-arrA-u, .arr-wrap .s2.icon-arrA-r, .arr-wrap .s2.icon-arrA-d, .arr-wrap .s2.icon-arrA-l&#123;z-index: 0; &#125;.arr-wrap .s1.icon-arrA-r, .arr-wrap .s2.icon-arrA-l&#123;left: 0; &#125;.arr-wrap .s2.icon-arrA-r, .arr-wrap .s1.icon-arrA-l&#123;left: 2px; &#125;.arr-wrap .s1.icon-arrA-u&#123;border-bottom-color: #fff; &#125;.arr-wrap .s2.icon-arrA-u&#123;border-bottom-color: #e6e6e6; &#125;.arr-wrap .s1.icon-arrA-r&#123;border-left-color: #fff; &#125;.arr-wrap .s2.icon-arrA-r&#123;border-left-color: #e6e6e6; &#125;.arr-wrap .s1.icon-arrA-d&#123;border-top-color: #fff; &#125;.arr-wrap .s2.icon-arrA-d&#123;border-top-color: #ddd; &#125;.arr-wrap .s1.icon-arrA-l&#123;border-right-color: #fff; &#125;.arr-wrap .s2.icon-arrA-l&#123;border-right-color: #e6e6e6; &#125;/* 箭头边框阴影 */.arr-wrap-su&#123;width: 20px;height: 20px;&#125;.arr-wrap-su::after&#123;content: ''; position: absolute; z-index: -1; width: 8px; height: 8px; background: #fff; left: 4px; top: 12px; border-width: 1px 1px 0 0; border-style: solid; border-color: #e6e6e6; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); transform: rotate(-45deg); box-shadow: 2px -2px 5px #e6e6e6; -webkit-box-shadow: 2px -2px 5px #e6e6e6; -moz-box-shadow: 2px -2px 5px #e6e6e6; &#125;/* 纯css实现箭头样式 E*/ 五、ie6兼容问题 链接伪类（:hover）CSS背景图片有闪动 1&lt;!--[if IE 6]&gt;&lt;script&gt;document.execCommand("BackgroundImageCache", false, true)&lt;/script&gt;&lt;![endif]--&gt; border兼容transparent 1_border-color:tomato;_filter:chroma(color=tomato); 兼容fixed 1.fixed&#123;position:fixed; top:35%; right:0; _position:absolute; _top:expression(offsetParent.scrollTop+100); _right:expression(offsetParent.scrollRight);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F03%2F11%2Fgitskill%2F</url>
    <content type="text"><![CDATA[创建版本库 初始化一个Git仓库，使用 git init 命令 添加文件到仓库: 第一步：使用命令 git add [file]，可以反复多次使用，添加多个文件 第二步：使用命令 git commit 查看仓库目前状态 git status:掌握工作区的状态,查看文件是否被修改过(但还没有准备提交的修改) git diff:可以查看修改内容 git diff 比对当前内容和暂存区内容。 git diff HEAD 比对当前内容和最近一次提交。 git diff HEAD^ 比对当前内容和倒数第二次提交。 git diff HEAD^ HEAD 比对最近两次提交。 版本回退 HEAD指向的版本就是当前版本，git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id git log查看提交历史，以便会退到哪个版本 git log [--oneline] [--all] 查看提交历史。 git log --oneline 打印为单行log。 git log --all 打印所有记录（忽略HEAD的位置）。 git log --graph 打印示意图（忽略HEAD的位置）。 git reflog查看命令历史，以便确定要回到未来哪个版本 撤销修改 git checkout -- file:直接丢弃工作区的修改 丢弃暂存区的修改:用git reset HEAD file回到上一步 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库 删除文件 第一步：git rm [file] 第二步：git commit 添加远程库 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 ps:由于公司防火墙通过ssh不能连接github，需要设置http代理来连接 设置代理：git config --global http.proxy 192.168.xx.xxx:xxxx 移除代理：git config --system --unset http.proxy 从远程库克隆 git clone https://github.com/xx/xx.git 拉取远程仓库 git pull 分支管理 查看分支:git branch 创建分支：git branch [name] 切换分支：git checkout [name] 创建+切换分支：git checkout -b [name] 合并某分支到当前分支：git merge [name] 删除分支：git branch -d [name] 修改文件后提交 并提交到github 步骤： 创建并切换分支: git checkout -b [name] 添加修改过的文件: git add [file] 提交文件: git commit -m &quot;描述&quot; 切换到master分支: git checkout [name] 合并修改文件的分支到当前分支: git merge [name] 删除修改文件的分支: git branch -d [name] 提交到远程库: git push origin master 参考]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常用方法收集]]></title>
    <url>%2F2018%2F03%2F11%2Fjavascript-function%2F</url>
    <content type="text"><![CDATA[一、获取id和ClassName1234567891011121314151617181920212223242526272829303132333435363738394041//获取idfunction getId(id) &#123; return (typeof id == "object") ? id : document.getElementById(id);&#125;//获取ClassNamefunction getElementsByClassName(name) &#123; var tags = document.getElementsByTagName('*') || document.all; var els = []; for (var i = 0; i &lt; tags.length; i++) &#123; if (tags.className) &#123; var cs = tags.className.split(' '); for (var j = 0; j &lt; cs.length; j++) &#123; if (name == cs[j]) &#123; els.push(tags); break &#125; &#125; &#125; &#125; return els&#125;//解决IE8之类不支持getElementsByClassNameif (!document.getElementsByClassName) &#123; document.getElementsByClassName = function(className, element) &#123; var children = (element || document).getElementsByTagName('*'); var elements = new Array(); for (var i = 0; i &lt; children.length; i++) &#123; var child = children[i]; var classNames = child.className.split(' '); for (var j = 0; j &lt; classNames.length; j++) &#123; if (classNames[j] == className) &#123; elements.push(child); break; &#125; &#125; &#125; return elements; &#125;;&#125; 二、获取页面常用高度及兼容1234567891011121314// 浏览器窗口可视区域大小（不包括工具栏和滚动条等边线）var client_w = document.documentElement.clientWidth || document.body.clientWidth;var client_h = document.documentElement.clientHeight || document.body.clientHeight;// 网页内容实际宽高（包括工具栏和滚动条等边线）var scroll_w = document.documentElement.scrollWidth || document.body.scrollWidth;var scroll_h = document.documentElement.scrollHeight || document.body.scrollHeight;// 网页内容实际宽高 (不包括工具栏和滚动条等边线）var offset_w = document.documentElement.offsetWidth || document.body.offsetWidth;var offset_h = document.documentElement.offsetHeight || document.body.offsetHeight;// 滚动的高度var scroll_Top = document.documentElement.scrollTop||document.body.scrollTop; 三、时间个性化输出1234567891011121314151617181920212223242526272829303132333435363738394041//时间个性化输出/*1、&lt; 60s, 显示为“刚刚”2、&gt;= 1min &amp;&amp; &lt; 60 min, 显示与当前时间差“XX分钟前”3、&gt;= 60min &amp;&amp; &lt; 1day, 显示与当前时间差“今天 XX:XX”4、&gt;= 1day &amp;&amp; &lt; 1year, 显示日期“XX月XX日 XX:XX”5、&gt;= 1year, 显示具体日期“XXXX年XX月XX日 XX:XX”*/function timeFormat(time)&#123; var date = new Date(time), curDate = new Date(), year = date.getFullYear(), month = date.getMonth() + 10, day = date.getDate(), hour = date.getHours(), minute = date.getMinutes(), curYear = curDate.getFullYear(), curHour = curDate.getHours(), timeStr; if(year &lt; curYear)&#123; timeStr = year +'年'+ month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else&#123; var pastTime = curDate - date, pastH = pastTime/3600000; if(pastH &gt; curHour)&#123; timeStr = month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else if(pastH &gt;= 1)&#123; timeStr = '今天 ' + hour +':'+ minute +'分'; &#125;else&#123; var pastM = curDate.getMinutes() - minute; if(pastM &gt; 1)&#123; timeStr = pastM +'分钟前'; &#125;else&#123; timeStr = '刚刚'; &#125; &#125; &#125; return timeStr;&#125; 四、返回顶部的通用方法123456789101112131415161718192021//返回顶部的通用方法function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = 'none'; btn.onclick = function() &#123; btn.style.display = 'none'; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': 'none' &#125;&#125;;backTop('goTop'); 五、事件委托1234567891011121314151617//关于编写性能高效的javascript事件的技术&lt;input type="button" id="btn" name="btn" value="BUTTON"/&gt;&lt;a href="#" id="aa"&gt;aa&lt;/a&gt;&lt;script&gt;document.addEventListener("click",function(evt)&#123; var target = evt.target; switch(target.id)&#123; case "btn": alert("button"); break; case "aa": alert("a"); break; &#125;&#125;,false);&lt;/script&gt; 六、倒计时1234567891011121314151617181920212223242526272829303132333435363738/** * 活动倒计时 * @param &#123;string&#125; expiry endtine * @param &#123;object&#125; obj element */function getTime(expiry,obj) &#123; if(expiry == "" || !obj)&#123;return;&#125; var now = new Date(); var expiry = expiry; var a = now.getFullYear() + '.' + (now.getMonth()+1) + '.' + now.getDate() +' ' + now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds(); var b = expiry; var startTime = new Date(a); var endTime = new Date(b); if ( endTime &lt;= now) &#123; obj.innerHTML = "距离活动开始还有&lt;i class='s-blue'&gt;00&lt;/i&gt;天&lt;i class='s-blue'&gt;00&lt;/i&gt;时&lt;i class='s-blue'&gt;00&lt;/i&gt;分&lt;i class='s-blue'&gt;00&lt;/i&gt;秒"; &#125; else &#123; var days = (endTime - now) / 1000 / 60 / 60 / 24; var daysRound = checkTime(Math.floor(days)); var hours = (endTime - now) / 1000 / 60 / 60 - (24 * daysRound); var hoursRound = checkTime(Math.floor(hours)); var minutes = (endTime - now) / 1000 / 60 - (24 * 60 * daysRound) - (60 * hoursRound); var minutesRound = checkTime(Math.floor(minutes)); var seconds = (endTime - now) / 1000 - (24 * 60 * 60 * daysRound) - (60 * 60 * hoursRound) - (60 * minutesRound); var secondsRound = checkTime(Math.round(seconds)); obj.innerHTML = '距离活动开始还有:&lt;i class="s-blue"&gt;'+ daysRound +'&lt;/i&gt;天&lt;i class="s-blue"&gt;'+ hoursRound +'&lt;/i&gt;时&lt;i class="s-blue"&gt;'+ minutesRound +'&lt;/i&gt;分&lt;i class="s-blue"&gt;'+ secondsRound +'&lt;/i&gt;秒'; function _getTime(expiry)&#123; return function()&#123; getTime(expiry,obj) &#125; &#125; newtime = window.setTimeout(_getTime(expiry,obj), 1000); &#125;&#125; 七、常用正则表达式 正整数: /^[0-9]*[1-9][0-9]*$/ 负整数: /^-[0-9]*[1-9][0-9]*$/ 正浮点数: /^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/ 负浮点数: /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/ 浮点数: /^(-?\d+)(\.\d+)?$/ email地址: /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/ url地址: /^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$/ 年/月/日（年-月-日、年.月.日）:/^(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/ 匹配中文字符: /[\u4e00-\u9fa5]/ 匹配空白行: /\n\s*\r/ 匹配中国邮政编码: /[1-9]\d{5}(?!\d)/ 匹配身份证(只是对格式进行检验)：/\d{15}|\d{18}/ 匹配国内电话号码：/(\d{3}-|\d{4}-)?(\d{8}|\d{7})?/ 匹配首尾空白字符: /^\s*|\s*$/ 匹配HTML标记：/&lt; (\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;/ 腾讯 QQ 号: /^[1-9]*[1-9][0-9]*$/ 中文、英文、数字及下划线: /^[\u4e00-\u9fa5_a-zA-Z0-9]+$/ 八、增删class12345678910111213141516//判断是否有这个classfunction hasClass( elements,cName )&#123; return !!elements.className.match( new RegExp( "(\\s|^)" + cName + "(\\s|$)") );&#125;;//添加classfunction addClass( elements,cName )&#123; if( !hasClass( elements,cName ) )&#123; elements.className += " " + cName; &#125;;&#125;;//移除classfunction removeClass( elements,cName )&#123; if( hasClass( elements,cName ) )&#123; elements.className = elements.className.replace( new RegExp( "(\\s|^)" + cName + "(\\s|$)" ), " " ); &#125;;&#125;; 九、封装cookie组件12345678910111213141516171819202122232425262728293031323334var Cookie = &#123; // 读取 get: function(name)&#123; var cookieStr = "; "+document.cookie+"; "; var index = cookieStr.indexOf("; "+name+"="); if (index!=-1)&#123; var s = cookieStr.substring(index+name.length+3,cookieStr.length); return unescape(s.substring(0, s.indexOf("; "))); &#125;else&#123; return null; &#125; &#125;, // 设置 set : function(name,value,expires)&#123; var expDays = expires*24*60*60*1000; var expDate = new Date(); expDate.setTime(expDate.getTime()+expDays); var expString = expires ? "expires="+expDate.toGMTString() : ""; var pathString = ";path=/"; document.cookie = name + "=" + escape(value) + expString + pathString; &#125;, // 删除 del : function(name)&#123; var exp = new Date(new Date().getTime()-1); var s=this.read(name); if(s!=null) &#123; document.cookie= name + "="+s+"expires="+exp.toGMTString()+";path=/" &#125; &#125;&#125;;// demo:Cookie.set("xxx", "xx", 7);alert(Cookie.get("xxx"));Cookie.del("xxx"); 十、类型转换函数123456789101112131415161718192021222324252627var Converter = &#123; toDate: function(strDate)&#123; var sDate = strDate.replace(/(^\s+|\s+$)/g,''); //去两边空格; if(sDate=='')&#123; return null; &#125; var s = sDate.replace(/[\d]&#123;4,4&#125;[\-/]&#123;1&#125;[\d]&#123;1,2&#125;[\-/]&#123;1&#125;[\d]&#123;1,2&#125;/g, ''); if (s == '') &#123; var t=new Date(sDate.replace(/\-/g,'/')); var ar = sDate.split(/[-/:]/); if(ar[0] == t.getFullYear() &amp;&amp; ar[1] == t.getMonth() + 1 &amp;&amp; ar[2] == t.getDate()) &#123; return t; //返回转化成功的日期对象 &#125; &#125; return null; &#125;&#125;;console.log(Converter.toDate("2014/9/2"));console.log(Converter.toDate("2014-9-2"));console.log(Converter.toDate("2014-09-02"));// Tue Sep 02 2014 00:00:00 GMT+0800 (中国标准时间) 十一、动态脚本元素12345678910111213141516171819/** * 加载JS文件 * @param &#123;string&#125; url 资源url * @param &#123;function&#125; callback 回调函数 * @param &#123;string&#125; charset 资源编码 */function loadScript(url, callback, charset) &#123; var oscript = document.createElement('script'); if(charset) oscript.charset = charset; oscript.src = url; oscript.onload = oscript.onreadystatechange = function() &#123; if (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete') &#123; oscript.onload = oscript.onreadystatechange = null; callback &amp;&amp; callback(); oscript.parentNode.removeChild(oscript); &#125; &#125;; document.body.insertBefore(oscript, document.body.firstChild);&#125; 十二、js数组去重1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var Unique = &#123; /** * 双重循环去重（经过测试超过两个重复的会留下两个） * @param arr * @returns &#123;*&#125; */ dbloop: function (arr) &#123; var i, j, res = []; for (i = 0; i &lt; arr.length; i++) &#123; for (j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(i, 1);//当出现相同的元素时，删除重复的元素 &#125; &#125; &#125; return arr; &#125;, /** * 哈希表形式 * @param arr * @returns &#123;Array&#125; */ hash: function (arr) &#123; var i, hash = &#123;&#125;, res = []; //查询hash对象是否存在当前元素(属性) for (i = 0; i &lt; arr.length; i++) &#123; if (!hash[arr[i]]) &#123; res.push(arr[i]); hash[arr[i]] = true; &#125; &#125; return res; &#125;, /** * 借助indexOf方法 * @param arr * @returns &#123;Array&#125; */ indexOf: function (arr) &#123; var i, res = []; //查询空数组里面是否已经存在这个值，不存在则推入 for (i = 0; i &lt; arr.length; i++) &#123; if (res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]); console.log(arr[i]); &#125; &#125; return res; &#125;&#125;; 十三、删除左右空格1234//删除左右空格function trim(str) &#123; return str.replace(/(^\s*)|(\s*$)/g, '');&#125; 十四、判断图片是否加载完1234567functionloadImage1(url,callback)&#123; varimg = newImage(); img.onload = function()&#123; //图片加载完成后执行的操作 &#125; img.src = url;&#125; 十五、图片按某个尺寸等比缩放12345678910function imgRatio(picW,picH,maxWidth,maxHeight)&#123; var Ratio, wRatio = maxWidth / picW, hRatio = maxHeight / picH; if(wRatio &lt; 1 || hRatio &lt; 1)&#123; Ratio = Math.min(wRatio, hRatio); picW = picW * Ratio; picH = picH * Ratio; &#125; &#125; 十六、遍历document.querySelectorAll()方法返回的结果12345678910111213// forEach method, could be shipped as part of an Object Literal/Modulevar forEach = function (array, callback, scope) &#123; for (var i = 0; i &lt; array.length; i++) &#123; callback.call(scope, i, array[i]); // passes back stuff we need &#125;&#125;;// 用法:// optionally change the scope as final parameter too, like ECMA5var myNodeList = document.querySelectorAll('li');forEach(myNodeList, function (index, value) &#123; console.log(index, value); // passes index + value back!&#125;); 十七、内容向上滚动，有停顿1234567891011121314151617181920212223242526272829303132333435363738394041/** * 用于内容向上滚动，有停顿 * @param &#123;object&#125; obj 元素 * @param &#123;number&#125; speed 滚动速度（滚动一个子元素高度的时间，单位毫秒） * @param &#123;number&#125; delay 停顿时间 */function startmarquee(obj, speed, delay) &#123; var t; var p = false; var o = obj; var h; if (!o || o.children.length &lt; 2) return true; o.innerHTML += o.innerHTML; o.scrollTop = 0; h = o.children[0].clientHeight; o.onmouseover = function() &#123; p = true; &#125;; o.onmouseout = function() &#123; p = false; &#125;; function start() &#123; t = setInterval(scrolling, speed / h); if (!p) o.scrollTop += 1; &#125; function scrolling() &#123; if (o.scrollTop % h != 0) &#123; o.scrollTop += 1; if (o.scrollTop &gt;= o.scrollHeight / 2) o.scrollTop = 0; &#125; else &#123; clearInterval(t); setTimeout(start, delay); &#125; &#125; setTimeout(start, delay);&#125; 十八、事件处理兼容写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var eventUtil = &#123; // event兼容 getEvent: function(event) &#123; return event ? event : window.event; &#125;, // target兼容 getTarget: function(event) &#123; return event.target ? event.target : event.srcelem; &#125;, // 添加事件句柄 addHandler: function(elem, type, listener) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type, listener, false); &#125; else if (elem.attachEvent) &#123; elem.attachEvent('on' + type, listener); &#125; else &#123; // 在这里由于.与'on'字符串不能链接，只能用 [] elem['on' + type] = listener; &#125; &#125;, // 移除事件句柄 removeHandler: function(elem, type, listener) &#123; if (elem.removeEventListener) &#123; elem.removeEventListener(type, listener, false); &#125; else if (elem.detachEvent) &#123; elem.detachEvent('on' + type, listener); &#125; else &#123; elem['on' + type] = null; &#125; &#125;, // 添加事件代理 addAgent: function (elem, type, agent, listener) &#123; elem.addEventListener(type, function (e) &#123; if (e.target.matches(agent)) &#123; listener.call(e.target, e); // this 指向 e.target &#125; &#125;); &#125;, // 取消默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 阻止事件冒泡 stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;; 十九、innerText兼容火狐12345678910111213//跨浏览器获取innerTextfunction getInnerText(element)&#123; return (typeof element.textContent == 'string') ? element.textContent : element.innerText;&#125;//跨浏览器设置innerTextfunction setInnerText(element,text)&#123; if(typeof element.textContent == 'string')&#123; element.textContent = text; &#125;else&#123; element.innerText = text; &#125;&#125; 二十、throttle(节流)和debounce(防抖)1、throttle(节流) 应用场景(需要间隔一定时间触发回调来控制函数调用频率) mousemove mousedown/keydown mousemove keyup 监听滚动事件判断是否到页面底部自动加载更多1234567891011121314151617181920212223242526//函数节流（throttle）function throttle(fn, threshhold, scope) &#123; threshhold || (threshhold = 250); var last, timer; return function() &#123; var context = scope || this; var now = +new Date(), args = arguments; if (last &amp;&amp; now - last + threshhold &lt; 0) &#123; clearTimeout(deferTimer); timer = setTimeout(function() &#123; last = now; fn.apply(context, args); &#125;, threshhold); &#125; else &#123; last = now; fn.apply(context, args); &#125; &#125;&#125;//调用方法$('body').on('mousemove', throttle(function(event)&#123; console.log('tick');&#125;, 1000)); 2、debounce(防抖) 应用场景(对于连续的事件响应我们只需要执行一次回调) 每次 resize/scroll 触发统计事件 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）12345678910111213141516//函数去抖function debounce(fn, delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay) &#125;&#125;//调用方法$('input.username').keypress(debounce(function()&#123; //do the Ajax request&#125;, 250)) 二十一、移动端网络状态判断 123456789101112131415161718192021 //网络状态判断;(function(window)&#123; navigator.onLine ? online() : errorTip(); window.addEventListener("online", online, false); window.addEventListener("offline", offline, false); //重新连接 function online() &#123; //去掉提示 &#125; //连接断开 function offline() &#123; //触发事件 //显示提示 errorTip(); &#125; //错误提示 function errorTip()&#123; alert("网络异常，请稍后再试") &#125;&#125;(window)); 二十二、判断浏览器是否支持 placeholder 123function placeholderSuport() &#123; return "placeholder" in document.createElement("input")&#125; 二十三、判断移动端设备(简单)1234567891011121314151617181920212223242526// 判断设备来源function deviceType()&#123; var ua = navigator.userAgent; var agent = ['Android', 'iPhone', 'Symbian05', 'Windows Phone', 'iPad', 'iPod']; for (var i = 0; i &lt; agent.length; i++) &#123; if (ua.indexOf(agent[i] &gt; 0)) &#123; break; &#125; &#125;&#125;// 判断是否是微信function isWechat()&#123; var ua = navigator.userAgent.toLowerCase(); return ua.match(/MicroMessage/i) == 'micromessager' ? true : false;&#125;// 判断是安卓还是iOSfunction isAndroid()&#123; var ua = navigator.userAgent.toLowerCase(); return /iphone|ipad|ipod/.test(ua) ? false : true;&#125; 二十四、解决不支持console.log报错1var console = console || &#123;log: function() &#123;return;&#125;&#125; 二十五、js类型判断12345678910var a = '';var type = Object.prototype.toString.call(a)// Number: [object Number]// String: [object String]// Array: [object Array]// Object: [object Object]// Boolean: [object Boolean]// Null: [object Null]// Undefined: [object Undefined]// Function: [object Function]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令备忘]]></title>
    <url>%2F2018%2F03%2F04%2Fhexo%2F</url>
    <content type="text"><![CDATA[一、安装npm install -g hexo-cli 二、建站$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 三、生成静态页面hexo generate 四、启动本地服务，进行文章预览调试hexo server 五、每次部署的步骤hexo cleanhexo generatehexo deploy 六、写作hexo new [layout] &lt;title&gt; 查看官网]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glue安装步骤及常用命令]]></title>
    <url>%2F2018%2F03%2F04%2Fglue%2F</url>
    <content type="text"><![CDATA[一、windows安装步骤 安装Python 安装PIL 安装 Python 的 easy_install 添加Python的脚本目录到path 运行如下命令 easy_install glue 二、常用命令 1.快速: glue 源文件夹名称 输出文件夹名称glue source output 2.排序：glue source output --square|vertical|hortizontal|diagonal|vertical-right|horizontal-bottom 3.去掉图片多余的空白glue source output --crop 4.在不同的文件夹下生成css和imgglue source --img=images/compiled --css=css/compiled 5.生成一个测试的htmlglue source output --html 6.更改文件格式glue source output --less 7.展开间距并且不计算为宽高glue source output --10glue source output --&#39;10 20&#39;glue source output --&#39;10 20 30 40&#39; 8.排序glue source output --maxside|width|height|area|filenameglue source output ---maxside|-width|-height|-area|-filename 9.在图像周围填充间距glue source output --10glue source output --10 20glue source output --10 20 30 40 10.图片格式glue source output --png8 11.后台监听glue source output --watch 参考]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>glue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text使用技巧]]></title>
    <url>%2F2017%2F08%2F13%2Fsublime%2F</url>
    <content type="text"><![CDATA[常用快捷键 新建文件：ctrl + n 定义文件类型： ctrl + shift + p, 输入指定的文件类型 复制缩进：ctrl + shift + v 复制一行：ctrl + shift + d 向上插入新行：ctrl + shift + enter 向下插入新行：ctrl + enter 选择一行：ctrl + l 显示/隐藏测导航：ctrl + k + b 打开匹配文件：ctrl + p ,可以输入路径、文件名、#页面匹配、@选择器/函数、:行数 多行游标： 1、ctrl + h 2、ctrl + d（ctrl + k + d: 跳过选中的内容） 3、ctrl + a, ctrl + l 4、shift + 鼠标右键拖动 插件Emment ! + tab 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; ul&gt;.item$*10 + tab 123456789101112&lt;ul&gt; &lt;li class="item1"&gt;&lt;/li&gt; &lt;li class="item2"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;li class="item6"&gt;&lt;/li&gt; &lt;li class="item7"&gt;&lt;/li&gt; &lt;li class="item8"&gt;&lt;/li&gt; &lt;li class="item9"&gt;&lt;/li&gt; &lt;li class="item10"&gt;&lt;/li&gt;&lt;/ul&gt; h2{text} + tab 1&lt;h2&gt;text&lt;/h2&gt; advanceNewFile 在当前文件下建立新文件 快捷键：ctrl + shift + n]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记]]></title>
    <url>%2F2017%2F08%2F09%2Fes6%2F</url>
    <content type="text"><![CDATA[一、var、let、const1、var: 无论在代码的那个地方声明，都会提升到该函数的开头（变量提升）；栗子：12345for(var i = 0; i &lt; 10; i ++)&#123;&#125;console.log(i); //10 2、let：用法类似于var，但不会变量提升，只在let命令所在的代码块内有效；栗子：12345for(let i = 0; i &lt; 10; i ++)&#123;&#125;console.log(i); //i is not defined 3、const: 声明常量，一旦声明，不可更改（不是变量的值不能改动，而是变量指向的那个内存地址不得改动，见例3），而且常量必须初始化赋值，和let一样，只在声明所在的块级作用域内有效；栗子1：12345// 更改值的情况const PI = 3.1415;console.log(PI);PI = 3;// Assignment to constant variable. 栗子2：123// 未赋值的情况const PI// Missing initializer in const declaration 栗子3：123456// 对象声明const foo = &#123;&#125;;foo.prop = 123;console.log(foo.prop) // 123foo = &#123;&#125; //Assignment to constant variable. 二、解构赋值1、数组的解构赋值 从数组中提取值，按照对应位置，对变量赋值1let [a, b, c] = [1, 2, 3]; 待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript知识点笔记]]></title>
    <url>%2F2017%2F04%2F30%2Fjavascript-base%2F</url>
    <content type="text"><![CDATA[一、break、 continue 和 return 的用法 break：会使运行的程序立刻退出包含在最内层的循环或者退出一个switch语句栗子1：12345for(var i=1;i&lt;=10;i++)&#123; if(i==6) break; document.write(i);&#125;//输出结果：12345 continue：和break相似，不同的是，它不是退出一个循环，而是开始循环的一次新迭代，continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内，在其它地方使用都会引起错误！ return： return语句就是用于指定函数返回的值。return语句只能出现在函数体内，出现在代码中的其他任何地方都会造成语法错误！ 二、instanceof： A instanceof B A 是一个对象，B 是定义类的构造函数，如果 A 是 B 的实例，返回true，（也就是说，如果 A 继承自 B.prototype，返回true；这里的继承可以不是直接继承，如果 A 所继承的对象继承自另一个对象， B 继承自 B.prototype，返回的结果也为true）; constructor 检测对象是否属于某个类 每个javascript函数都自动拥有一个 prototype 属性，这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor，constructor 属性的值是一个函数对象。 新定义的 prototype 不含有 constructor 属性 栗子1：123456var F = function()&#123;&#125;var p = F.prototype; // 这是与F相关联的原型对象var c = p.constructor; // 这是与原型相关联的函数c === F; // true, 对于任意函数F.prototype.constructor == F// 可以看到构造函数的原型中存在预先定义好的constructor 属性，这意味着对象通常继承的constructor均指代它们的构造函数。 栗子2：12var o = new F();o.constructor === F; // true,constructor属性指代这个类 三、hasOwnProperty A.hasOwnProperty(“B”); A 对象，B 属性名，如果 B 是 A 的自有属性 (B 不是 A的继承属性)，则返回true。 栗子1：1234var o = &#123; x: 1 &#125;;o.hasOwnProperty("x"); //true,o 有一个自有属性 xo.hasOwnProperty("y"); // false, o 中不存在属性 yo.hasOwnProperty("toString"); //false, toString 是继承属性 四、in “A” in B A 是属性名（字符串），B 是对象，如果对象的自有属性或继承属性中包含这个属性则返回true 可以区分不存在的属性和存在但值为undefined的属性 栗子1：1234var o = &#123; x: 1 &#125;;"x" in o; // true "x"是 o 的属性"y" in o; // false "y"不是 o 的属性"toString" in o; // true o 继承 toString 属性 五、call() / apply() 改变this的指向； 当一个 对象 没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。 1、call() 参数长度确定时使用 A.call(B, arg1, arg2…) 2、apply() 参数长度不确定时使用 A.call(B, [arg1, arg2…]) 栗子1：（from MDN web docs）调用父构造函数123456789101112131415161718function Product(name, price)&#123; this.name = name; this.price = price;&#125;//===============call==============function Food(name, price)&#123; Product.call(this, name, price); this.category = 'food';&#125;等同于：function Food(name, price)&#123; this.name = name; this.price = price; this.category = 'food';&#125; 栗子2：（from MDN web docs）调用匿名函数12345678910111213141516//===============call==============var animals = [ &#123;species: 'Lion', name:'King'&#125;, &#123;species: 'Whale', name:'Fail'&#125;];for(var i = 0; i &lt; animals.length; i++)&#123; (function(i)&#123; this.print = function()&#123; console.log("#" + i + " " + this.species + ": " + this.name); &#125; this.print(); &#125;).call(animals[i], i)&#125; 栗子3：（from MDN web docs）调用函数并且指定上下文的’this’ 12345678910function greet()&#123; var reply = [this.person, 'Is An Awesome', this.role].join(' '); console.log(reply);&#125;var i = &#123; person: 'Douglas Crockford', role: 'Javascript Developer'&#125;greet.call(i); //Douglas Crockford Is An Awesome Javascript Developer 六、forEach() 遍历数组的函数,传递的函数做为forEach的第一个参数，forEach使用三个参数调用该函数：数组元素，元素的索引，数组本身；【注意：forEach无法在所有元素都传递给调用函数的函数之前终止遍历（即没有像for循环中使用的相应的break语句），如果需要终止循环，必须把forEach()放在一个try块中，并能抛出一个异常，如果forEach()调用函数抛出foreach.break异常，循环会提前终止】 12345data.forEach(function(v, i ,a)&#123;// v:数组元素// i：元素索引// a：数组本身&#125;) 七、cloneNode() 创建节点的拷贝，并返回该副本；克隆所有属性以及它们的值。 语法：var dupNode = node.cloneNode(deep); dupNode：要克隆的节点 node：克隆的新节点 node deep(可选)： true==&gt;克隆所有后代;false只克隆指定的节点 栗子：（from W3School）12345678910111213141516171819202122232425262728//html&lt;ul id="myList1"&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id="myList2"&gt;&lt;li&gt;Water&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// jsvar node=document.getElementById("myList2").lastChild.cloneNode(true);document.getElementById("myList1").appendChild(node);&lt;/script&gt;// 克隆之前//myList1:CoffeeTea//myList2:WaterMilk// 克隆之后//myList1:CoffeeTeaMilk//myList2:WaterMilk 八、cssText 批量修改样式，可以尽量避免页面reflow，提高页面性能 会把原有的cssText清掉, 所以最好使用 累加 的方法； 1234element.style.cssText += "width:20px;height:20px;border:solid 1px red;";// cssText（假如不为空）在IE中最后一个分号会被删掉，可以在前面添加一个分号Element.style.cssText += ‘;width:100px;height:100px;top:100px;left:100px;’ 九、setTimeout() / setInterval() 用来注册在指定的时间之后单次或重复调用的函数 两者都会返回一个值，可以传递给clearTimeout()用于取消这个函数的执行 由于历史原因，第一个参数可以作为字符串传入，如果这么做，那这个字符串会在指定的超时时间或间隔之后进行求值（相当与执行eval()） HTML5 规范还允许传入额外的参数（不支持IE） 1、setTimeout 用来实现一个函数在指定的毫秒数之后运行 2、setInterval 与setTimeout一样，只是这个函数会在指定毫秒数的间隔里重复调用1setInterval(undateClock, 60000);// 每60s调用一个undateClock 栗子：(form JavaScript 权威指南)123456789101112function invoke(f, start, interval, end)&#123; if(!start) start= 0 ; // 默认设置为0 ms if(arguments.length &lt;= 2)&#123; // 单次调用模式 setTimeout(f, start); // start ms 后 单次调用 f() &#125;else &#123; // 多次调用模式 setTimeout(repeat, start); // 在 start 调用repeat() function repeat()&#123; var h = setInterval(f, interval); // 循环调用f() if(end) setTimeout(function()&#123;clearInterval(h)&#125;, end);// 在end ms后停止调用，前提是end已经定义 &#125; &#125;&#125; 十、encodeURIComponent() / decodeURIComponent()1、encodeURIComponent 对统一资源标识符（URI）的组成部分进行编码的方法 转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符栗子：(from MDN web docs)123456789101112131415161718var fileName = 'my file(2).txt';var header = "Content-Disposition: attachment; filename*=UTF-8''" + encodeRFC5987ValueChars(fileName);console.log(header); // 输出 "Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt"function encodeRFC5987ValueChars (str) &#123; return encodeURIComponent(str). // 注意，仅管 RFC3986 保留 "!"，但 RFC5987 并没有 // 所以我们并不需要过滤它 replace(/['()]/g, escape). // i.e., %27 %28 %29 replace(/\*/g, '%2A'). // 下面的并不是 RFC5987 中 URI 编码必须的 // 所以对于 |`^ 这3个字符我们可以稍稍提高一点可读性 replace(/%(?:7C|60|5E)/g, unescape);&#125; 2、decodeURIComponent 用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI） 将已编码 URI 中所有能识别的转义序列转换成原字符栗子：(from MDN web docs)12decodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");// "JavaScript_шеллы" 十一、getBoundingClientRect() 返回元素在视口坐标中的位置，返回一个有left、right、top、bottom属性的对象。 left和top属性表示元素的左上角的X和Y坐标，right和bottom属性表示元素右下角的X和Y坐标 在很多浏览器中，还返回 width和height，在是在ie中未实现 不是实时的，在用户滚动或改变浏览器窗口大小时不会更新 栗子：（from JavaScript权威指南）1234567891011121314151617181920212223var box = e.getBoundingClientRect(); //获得在视口坐标中的位置var offsets = getScrollOffsets();var x = box.left + offset.x;var y = box.top + offset.yvar w = box.width || (box.right - box.left);var h = box.height || (box.bottom - box.top);// 滚动条位置function getScrollOffsets(w)&#123; w = w || window; // 除ie8- 版本，其他浏览器都能用 if(w.pageXOffset != null) return &#123;x: w.pageXOffset, y: w.pageYOffset&#125;; // 对标准模式下的浏览器 var d = w.document; if(document.compatMode == "CSS1Compat")&#123; return &#123;x: d.documentElement.scrollLeft, y： d.documentElement.scrollTop&#125;; &#125; // 对怪异模式下的浏览器 return &#123;x: d.body.scrollLeft, y: d.body.scrollTop&#125;;&#125; 十二、createDocumentFragment 作为其他节点的一个临时容器，是独立的，通常用在 创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树栗子：（from JavaScript权威指南）123456789101112// 倒叙排列节点n的子节点function reverse(n)&#123; // 创建一个DocumentFragment作为临时容器 var f = document.createDocumentFragment(); // 从后至前循环子节点，将每一个子节点移动到文档片段中 // 注意：给f添加一个节点，改节点自动的会从n中删除 while(n.lastChild) f.appendChild(n.lastChild); // 把f 的所有子节点一次性全部移回n中 n.appendChild(f);&#125; 十三、defaultView / getComputedStyle()1、defaultView 在浏览器中，该属性返回当前 document 对象所关联的 window 对象，如果没有，会返回 null 只读 IE 9 以下版本不支持 使用方式： document.defaultView 2、getComputedStyle 是一个可以获取当前元素所有最终使用的CSS属性值，返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读 语法：window.getComputedStyle(element, [pseudoElt]); element:用于获取计算样式的Element pseudoElt: 可选，指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。 栗子1：（from MDN web docs）12345let elem1 = document.getElementById("elemId");let style = window.getComputedStyle(elem1, null);// 它等价于// let style = document.defaultView.getComputedStyle(elem1, null); 栗子2：(from MDN web docs）12345678910111213141516171819202122&lt;style&gt; #elem-container&#123; position: absolute; left: 100px; top: 200px; height: 100px; &#125;&lt;/style&gt;&lt;div id="elem-container"&gt;dummy&lt;/div&gt;&lt;div id="output"&gt;&lt;/div&gt;&lt;script&gt; function getTheStyle()&#123; let elem = document.getElementById("elem-container"); //getPropertyValue()返回一个DOMString含有一个指定的CSS属性的值 let theCSSprop = window.getComputedStyle(elem,null).getPropertyValue("height"); document.getElementById("output").innerHTML = theCSSprop; &#125; getTheStyle();&lt;/script&gt; 待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html基础知识]]></title>
    <url>%2F2017%2F04%2F16%2Fbase-html%2F</url>
    <content type="text"><![CDATA[一、Doctype-&lt;!DOCTYPE&gt; 声明必须位于 HTML5 文档中的第一行，也就是位于 标签之前。该标签告知浏览器文档所使用的 HTML 规范。doctype 声明不属于 HTML 标签；它是一条指令，告诉浏览器编写页面所用的标记的版本。在所有 HTML 文档中规定 doctype 是非常重要的，这样浏览器就能了解预期的文档类型。HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行。）。 二、常用元素1、块级元素12345678910111213141516171819div - 常用块级容器，也是css layout的主要标签p - 段落ul - 无序列表dl - 定义列表ol - 排序表单table - 表格h1~h6 - 标题form - 交互表单pre - 格式化文本address - 地址blockquote - 块引用center - 居中对齐块dir - 目录列表fieldset - form控制组hr - 水平分割线menu - 菜单列表noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容）noscript - 可选脚本内容（对于不支持script的浏览器显示此内容） 2、行内元素123456789101112131415161718192021a - 锚点span - 常用内联容器，定义文本内区块em - 强调i - 斜体img - 图片label - 表格标签input - 输入框textarea - 多行文本输入框select - 项目选择abbr - 缩写acronym - 首字b - 粗体br - 换行strike - 中划线u - 下划线strong - 粗体强调sub - 下标sup - 上标code - 计算机代码(引用源码的时候需要)samp - 定义范例计算机代码 3、空元素123&lt;br&gt; - 换行&lt;hr&gt; - 水平分割线&lt;img&gt; - 图片 三、link和@import引入样式的区别 1、link属于XHTML标签，除了可以加载css外，还可以定义RSS、rel连接属性等；@import 是css提供的一种方式，只能加CSS。 2、加载顺序不同:当一个页面被加载的时候，link引用的css会同时被加载，而@import引用的css会等到页面全部被下载完再被加载，所有有时候浏览@import加载css的页面时开始会没有样式（闪烁），网速慢的时候很明显。 3、兼容性:link无兼容问题，@import只有在ie5以上的才能识别。 4、使用dom控制样式时的差别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。 5、@import可以在css中再次引入其他样式表。 三、浏览器内核 负责对网页语法的解释并渲染网页 常见的浏览器内核 Trident：IE浏览器使用的内核 Gecko：Netscape6开始采用的内核，火来的Mozilla FireFox也采用了该内核 Presto:目前Opera采用的内核 Webkit：苹果公司自己的内核 四、html51、新元素123内容元素：article、footer、header、nav、section表单控件：calender、date、time、email、url、search控件元素：webworker、wesockt、Geolocation 2、移除的元素12显现层元素：basefont、big、center、font、s、strike、tt、u性能较差元素：frame、framest、noframes 3.兼容 IE8/IE7/IE6支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签 使用html5shim框架 4、区分HTML和HTML5 DOCTYPE声明方式是区分HTML和HTML5标志的一个重要因素，还可以根据新增的结构、功能元素来加以区分 五、理解HTML语义化 语义化有利于SEO，有利于搜索引擎爬虫更好的理解网页，从而获取更多的有效信息，提升网页的权重。 在没有css的时候能够清晰的看出网页的节骨，增强可读性。 便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力 支持多端设备的浏览器渲染。 六、html5离线存储 将一些资源文件保存在本地，这样后续的页面重新加载将使用本地资源文件，在离线情况下可以继续访问web应用，同时通过一定的手法(更新相关文件或者使用相关API)，可以更新、删除离线存储等操作 基本流程：当第一次正确配置app cache后，当我们能再次访问该应用时，浏览器会首先检查manifest文件是否有变动。如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回。 七、cookies,sessionStorage和localStorage 共同点：都保存在浏览器端，且同源 区别： cookie： （1）始终在同源的http请求中携带（及时不需要），即cookie在浏览器和服务器间来回传递 ； （2）有路径的概念，可以限制cookie只属于某个路径下； （3）数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识； （4）只在设置的cookie过期时间之前一直有效，即窗口或浏览器关闭； （5）在所有同源窗口中都是共享的。 sessionStorage: （1）只做本地保存，不会自动把数据发给服务器 （2）数据可以达到5M或更多 （3）仅当前浏览器窗口关闭前有效 （4）在不同的浏览器窗口中不同享，即使是同一个页面 localStorage: （1）只做本地保存，不会自动把数据发给服务器 （2）数据可以达到5M或更多 （3）始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； （4）在所有同源窗口中都共享 八、iframe的优缺点 优点： （1）iframe能够原封不动的把嵌入的网页展现出来。 （2）如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 （3）网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 （4）如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点： （1）会产生很多页面，不容易管理。 （2）iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 （3）代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。 （4）很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 （5）iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 九、label的作用 label 标签为 input 元素定义标注（标记）。 label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 Label 中有两个属性是非常有用的,一个是FOR、另外一个就是ACCESSKEY了。 FOR属性 :表示Label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点。 ACCESSKEY属性：功能：表示访问Label标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。 十、html5的form如何关闭自动完成功能1&lt;form autocomplete="on/off"&gt; on 默认。规定启用自动完成功能。 off 规定禁用自动完成功能。 十一、实现一个圆形可点击区域 map+area 或者 svg; border-radius; 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等; 二、实现不使用border画出1px高的线，在不同浏览器的Quirksmode和CSSCompat下能保持一致1&lt;div style="height:1px;overflow:hidden;background:black"&gt;&lt;/div&gt; 十三、title和h1、b和strong、i和em的区别 title标签是用来描述这个页面的主题的，是一个网页权重的最高点。但title标签并不出现在文章的正文中。 h1标签一般出现在文章的正文中，是展示给访问者的文章的标题。所以说这两个标签不仅不冲突的，而是合作的关系。 一篇文章既要有title又要有h1标签，既突出了文章的主题，又突出了标题和关键字，达到双重优化网站的效果。一般会把title和h1标签的内容写成一样，而且一般情况下一篇文章最好只用一个h1标签，过多的h1标签反而会让搜索引擎迷糊，认不清文章的主题。 b与strong的区别、i与em的区别 b标签和strong标签给我们的主观感受都是加粗，但对搜索引擎来说b标签和普通的文字并没有什么区别，而strong标签却是起强调作用的。也就是说如果你想让搜索引擎认为你的某句话很重要时那就用strong标签。如果只是想让用户看到加粗的效果，那就用b标签。 em标签也是针对搜索引擎来起作用的，i标签只是让用户看到展示的是斜体。 参考 未完待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习]]></title>
    <url>%2F2017%2F04%2F04%2Fvuejs%2F</url>
    <content type="text"><![CDATA[一、Vue.js组件的重要选项1、data: vue对象的数据2、methods: vue对象的方法3、watch: 设置了对象监听的方法 1234567891011121314151617181920&lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt;&lt;script&gt;new Vue(&#123; data: &#123; a: 1, b: [] &#125;, methods: &#123; doSometh: function()&#123; console.log(this.a) &#125; &#125;, watch: &#123; 'a': function(val, oldVal)&#123; console.log(val, oldVal) &#125; &#125;&#125;)&lt;/script&gt; 二、模板指令——html和vue对象的粘合剂1、数据渲染：1v-text、v-html、 &#123;&#123; &#125;&#125; 1234567891011&lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt;&lt;p v-text="a"&gt;&lt;/p&gt;&lt;p v-html="a"&gt;&lt;/p&gt;&lt;script&gt;new Vue(&#123; data: [ a: 1, b: [] ]&#125;)&lt;script&gt; 2、控制模块隐藏： v-if、v-show12345678910&lt;p v-if="isShow"&gt;&lt;/p&gt;&lt;p v-show="isShow"&gt;&lt;/p&gt;&lt;script&gt; new Vue(&#123; data: &#123; isShow: true &#125;&#125;)&lt;/script&gt; 3、渲染循环列表： v-for1234567891011121314151617181920&lt;ul&gt; &lt;li v-for='item in items'&gt; &lt;p v-text='item.label'&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;...data: &#123; items: [ &#123; label: 'apple' &#125;, &#123; label: 'banana' &#125; ]&#125;...&lt;/script&gt; 4、事件绑定： v-on123456789&lt;button v-on:click="doThis"&gt;&lt;/button&gt;&lt;button @click="doThis"&gt;&lt;/button&gt;&lt;script&gt;...nethods: &#123; doThis: function(someThing)&#123;&#125;&#125;...&lt;/script&gt; 5、属性绑定： v-bind123456&lt;img v-bind:src="" alt=""&gt; //字符串&lt;img :src="" alt=""&gt;&lt;div ：class="&#123; red: isRed &#125;"&gt;&lt;/div&gt; //布尔值&lt;div ：class="[classA, classB]"&gt;&lt;/div&gt; //&lt;div ：class="[classA, &#123;classB: isB, classC： isC&#125;]"&gt;&lt;/div&gt; 未完待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass学习笔记]]></title>
    <url>%2F2017%2F03%2F27%2Fsass%2F</url>
    <content type="text"><![CDATA[一、常用命令 项目中常用：sass --watch sass:css --style compact 格式转换sass-convert style.sass style.scss 运行sasssass input.css output.css 监视sass文件，每次更新时，自动编译成csssass --watch input.scss: output.css 监视整个文件夹sass --watch app/sass:public/stylesheets 更多命令行sass --help 紧凑输出方式 campactsass --watch test.scss:test.css --style compact 压缩输出方式 campactsass --watch test.scss:test.css --style compressed 二、基本用法1、变量 使用$开头 1234$blue : #1875e7;div&#123; color: $blue;&#125; 如果变量需要镶嵌在字符串中，就必须需要写在#{}之中 1234$side: left;.rounded &#123; border-#&#123;$side&#125;-radius: 5px;&#125; 2、计算功能 例如123456$var: 500px;body&#123; margin: (14px/2); top:50px + 100px; right:$var * 10%&#125; 3、嵌套 标签嵌套 12345div&#123; h1&#123; color:red; &#125;&#125; 属性嵌套 12345p&#123; border:&#123; color:red; &#125;&#125; 伪类 12345a &#123; &amp;:hover&#123; color:#ffb3ff; &#125;&#125; 4、注释 会保留到编译后的文件/* */ 只保留在sass源文件中，编译后被省略// 主要注释，即使是压缩模式编译，也会保留这行注释，通常用作声明版权信息123/*! 重要注释*/ 三、代码重用4、继承 例如12345678.class1&#123; border: 1px solid #ddd;&#125;.class2&#123; @extend .class1; font-size: 120%;&#125; 5、Mixin 可以重用的代码块 12345678@mixin left($value: 10px)&#123; float: left; margin-right: $value;&#125;div&#123; @include left;&#125; 可以指定参数和缺省值 12345678910111213@mixin rounded($vert, $horz, $radius: 10px)&#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius;&#125;#navbar li&#123; @include rounded(top, left);&#125;#footer&#123; @include rounded(top, left, 5px);&#125; 6、颜色函数1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c 7、插入文件 @import命令，用来插入外部文件。 1 @import "path/filename.scss"; 如果插入的是.css文件，则等同于css的import命令。 1 @import "foo.css"; 四、高级用法1、条件语句 例1 123456789p &#123; @if 1 + 1 == 2 &#123; border:1px solid #eee; &#125; @if 5 &lt; 3 &#123; border:2px dotted #eee; &#125;&#125;等同于：p &#123; border: 1px solid #eee; &#125; 例2 12345678910p&#123; @if lightness($color) &gt; 30% &#123; background-color: #000; &#125; @else &#123; background-color: #fff; &#125;&#125;等同于：p &#123; background-color: #000; &#125; 2、循环语句 for循环 12345678910111213141516@for $i from 1 to 10&#123; .border-#&#123;$i&#125;&#123; border: #&#123;$i&#125;px solid blue; &#125;&#125;等同于：.border-1 &#123;border: 1px solid blue; &#125;.border-2 &#123;border: 2px solid blue; &#125;.border-3 &#123;border: 3px solid blue; &#125;.border-4 &#123;border: 4px solid blue; &#125;.border-5 &#123;border: 5px solid blue; &#125;.border-6 &#123;border: 6px solid blue; &#125;.border-7 &#123;border: 7px solid blue; &#125;.border-8 &#123;border: 8px solid blue; &#125;.border-9 &#123;border: 9px solid blue; &#125; while循环 12345678910111213$i: 6;@while $i &gt; 0&#123; .item-#&#123;$i&#125;&#123; width: 2em * $i; &#125; $i: $i - 2;&#125;等同于：.item-6 &#123;width: 12em; &#125;.item-4 &#123;width: 8em; &#125;.item-2 &#123;width: 4em; &#125; each 1234567891011@each $member in a,b,c,d&#123; .#&#123;$member&#125; &#123; background-image:url("/image/#&#123;$member&#125;.jpg"); &#125;&#125;等同于：.a &#123;background-image: url("/image/a.jpg"); &#125;.b &#123;background-image: url("/image/b.jpg"); &#125;.c &#123;background-image: url("/image/c.jpg"); &#125;.d &#123;background-image: url("/image/d.jpg"); &#125; 3、自定义函数 例如：12345678910@function double($n)&#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125;等同于：#sidebar &#123; width: 10px; &#125; ps: 参考,安装,调试,编译]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
</search>
