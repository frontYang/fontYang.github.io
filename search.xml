<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[canvas学习与实践]]></title>
    <url>%2F2018%2F03%2F31%2Fcanvas%2F</url>
    <content type="text"><![CDATA[一、canvas 与 SVG的区别 canvas和svg之间一个重要的区别：使用canvas来绘制图形是通过调用它提供的方法，而使用svg绘制图形是通过构建一棵XML元素树来实现 二、canvas基础 note: (摘自《javascript权威指南》) 1、定义上下文对象 大部分画布绘制的API都不是在&lt;canvas&gt;元素自身上定义的，而是定义在一个”绘制上下文”对象上，获取该对象可以通过调用画布的getContext()方法。12let canvas = document.getElementById('canvas');let ctx = canvas.getContext('2d'); 2、 绘制线段和填充多边形 图形属性 fillStyle：填充颜色/渐变/图案等样式 font：绘制文本css样式 globalAlpha：绘制像素时要添加的透明度 (?) globalCompositeOperation：如何合并新的像素点和下面的像素点 (?) lineCap：如何渲染线段末端 lineJoin：如何渲染顶点 lineWidth：外框线的宽度 miterLimit：紧急斜接顶点的最大长度 (?) textAlign：文本水平对齐方式 textBaseline：文本垂直对齐方式 shadowBlur：阴影的清晰或模糊程度 shadowColor：下拉阴影的颜色 shadowOffsetX：阴影的水平偏移量 shadowOffsetY：阴影的垂直偏移量 strokeStyle：勾勒线段时的颜色/渐变/图案等样式 案例: 12345678910111213141516171819202122232425262728293031323334353637// 定义一个以(x, y)为中心， 半径为r的规则n边形// 每个顶点都是均匀分布在圆周上// 将第一个顶点放置在最上面，或者指定一定角度// 除非最后一个参数是true，否则顺时针旋转function polygon(c, n, x, y, r, angle, counterclockwise)&#123; angle = angle || 0; counterclockwise = counterclockwise || false; ctx.moveTo(x + r * Math.sin(angle), // 从第一个顶点开始一条新的路径 y - r * Math.cos(angle)); // 使用三角形计算位置 let delta = 2 * Math.PI / n; // 两个顶点之间的夹角 for(let i = 1; i &lt; n; i ++)&#123; // 循环剩余的每个顶点 angle += counterclockwise ? -delta : delta; // 调整角度 ctx.lineTo(x + r * Math.sin(angle), // 以下个顶点为端点添加线段 y - r * Math.cos(angle)); &#125; ctx.closePath(); // 将最后一个顶点和起点连接起来&#125;ctx.beginPath();let x = 50;polygon(ctx, 3, x, 70, 50); // 三角形polygon(ctx, 4, x + x * 2, 60, 50, Math.PI / 4); // 正方形polygon(ctx, 5, x + x * 3, 55, 50); // 五边形polygon(ctx, 6, x + x * 4, 53, 50, Math.PI / 6); // 六边形polygon(ctx, 4, x + x * 5, 53, 20, Math.PI / 4, true); // 六边形中的小正方形ctx.fillStyle() = '#ccc'; // 内部填充颜色ctx.stockStyle = '#oo8'; // 边框颜色ctx.lineWidth = 5; // 边框跨度ctx.fill(); // 填充ctx.stroke(); // 勾勒外边框 (效果图) 3、画布的尺寸与坐标 (注：图片来自MDN) 4、坐标系变换（占坑）5、绘制和填充曲线 arc(ox, oy, radius, startRadian, endRadian, [true | false])： 在当前子路径中添加一条弧 参数： ox: 圆心x坐标 oy: 圆心y坐标 radius: 半径 startRadian: 起始弧 endRadian: 结束弧 true: 逆时针 | false: 顺时针 arcTo(x1, y1, x2, y2, radius):绘制一条直线和一段圆弧 x1: 起点x坐标 y1: 起点y坐标 x2: 终点x坐标 y2: 终点y坐标 radius:半径 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)：实现在当前子路径中添加一个新的点，并利用三次贝塞尔曲线将它和当前点相连(?) cp1x: 第一个控制点x坐标 cp1y: 第一个控制点y坐标 cp2x: 第二个控制点x坐标 cp2y: 第二个控制点y坐标 x: 结束点x坐标 y: 结束点y坐标 quadraticCurveTo(cpx, cpy, x, y)：与bezierCurveTo()类似，不同的是它使用的是二次贝塞尔曲线而不是三次贝塞尔曲线并且只有一个控制点(?) cpx: 控制点x坐标 cpy: 控制点y坐标 x: 结束点x坐标 y: 结束点y坐标 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142// 将角度转化成弧度制function rads(x)&#123; return Math.PI * x / 180;&#125;// 圆形ctx.beginPath();ctx.arc(75, 100, 50, 0, rads(360), false); // 圆心位于(75, 100), 半径为50, 从0°到360°顺时针旋转ctx.closePath(); // 闭合// 扇形ctx.moveTo(200, 100);ctx.arc(200, 100, 50, rads(-60), rads(0), false); // 顺时针ctx.closePath(); // 闭合ctx.moveTo(325, 100);ctx.arc(325, 100, 50, rads(-60), rads(0), true); // 逆时针ctx.closePath(); // 闭合// 直线+圆弧ctx.moveTo(450, 50); // 从上边的中点开始ctx.arcTo(500, 50, 500, 150, 30); //添加部分上边和右上角ctx.arcTo(500, 150, 400, 150, 30); // 添加右上角和右下角ctx.arcTo(400, 150, 400, 50, 10); // 添加底边和左下角ctx.arcTo(400, 50, 500, 550, 0); // 添加左边和左上角ctx.closePath(); // 闭合// 二次贝塞尔曲线ctx.moveTo(75, 250)ctx.quadraticCurveTo(100, 200, 175, 250); // 画一条以一直到点(175, 250)结束的曲线ctx.fillRect(100 - 3, 200 - 3, 6, 6); // 标记控制点(100, 200)// 三次贝塞尔曲线ctx.moveTo(200, 250);ctx.bezierCurveTo(220, 220, 280, 280, 300, 250); // 画一条以一直到点(300, 250)结束曲线ctx.fillRect(220 - 3, 220 - 3, 6, 6); // 标记控制点ctx.fillRect(280 - 3, 280 - 3, 6, 6);ctx.fillStyle = '#aaa';ctx.lineWidth = 5;ctx.fill();ctx.stroke(); (效果图) 6、矩形 fillRect(x,y,width,height): 使用当前点的fillStyle来填充指定的矩形 参数: x:矩形左上角的x坐标 y: 矩形左上角的y坐标 width: 矩形的宽度 height: 矩形的高度 strokeRect(x,y,width,height): 使用当前的strokeStyle和其他线段的属性来勾勒指定矩形的外边框，参数与fillRect()相同 clearRect(x,y,width,height): 清除矩形，参数与fillRect()相同 rect(x,y,width,height): 绘制矩形，会对当前路径产生影响，会在指定的矩形添加到当前路径的子路径中，参数与fillRect()相同 7、颜色、透明度、渐变、图案（占坑）8、文本 fillText(text, x, y, [maxWidth])：在画布上绘制填色的文本 参数: text: 文案 x: 开始绘制文本的x坐标(相对于画布) y: 开始绘制文本的y坐标(相对于画布) maxWidth: 可选，允许的最大文本宽度 strokeText(text, x, y, [maxWidth])： 在画布上绘制文本（无填充色），参数与fillText()相同 9、裁剪 clip(): 当调用此方法时，当路径自身就会裁剪到当前裁剪区域中，之后，被裁剪的路径就变成了新的裁剪区域，也就是说，此方法只会缩小裁剪区域，永远不会放大裁剪区域，由于没有提供重置裁剪区域的方法，因此在调用clip()之前通常要调用save()方法，以便于恢复为裁剪区域123456789101112131415161718192021ctx.font = 'bold 60pt san-serif'; // 设置字体ctx.lineWidth = 2; // 线段宽度ctx.strokeStyle = '#000'; // 线段颜色// 勾勒矩形轮廓和文本轮廓ctx.strokeRect(175, 20, 50, 325);ctx.strokeText = ('&lt;canvas&gt;', 15, 330);// note：polygon方法见上面的示例polygon(ctx, 3, 200, 225, 200); // 大三角形polygon(ctx, 3, 200, 225, 100, 0, true); // 小三角形ctx.clip(); // 将该路径定义成裁剪区域ctx.lineWidth = 10; // 另外5个像素的线段被裁剪了ctx.stroke();ctx.fillStyle = '#aaa'; // 填充颜色ctx.fillRect(175, 25, 50, 325); // 填充竖直的条带ctx.fillStyle = '#888'; // 填充颜色ctx.fillText('&lt;canvas&gt;', 15, 330); // 填充文本 (效果图) 10、阴影 shadowOffsetX属性和shadowOffsetY属性总是默认在坐标空间中的度量的，不受rotate()和scale()方法影响。 123456789101112131415// 不明显的阴影ctx.shadowColor = 'rgba(100, 100, 100, .4)'; // 半透明灰色ctx.shadowOffsetX = ctx.shadowOffsetY = 3; // 偏移阴影到右下角部分ctx.shadowBlur = 5; // 柔化阴影的边缘ctx.lineWidth = 10;ctx.strokeStyle = 'blue';ctx.strokeRect(100, 100, 300, 200); // 绘制一个巨型ctx.font = 'Bold 36pt Helvetica';ctx.fillText('Hello World', 115, 225); //绘制文本ctx.shaowOffsetX = ctx.shadowOffsetY = 20;ctx.shadowBlur = 10;ctx.fillStyle = 'red'; // 绘制一个红色的矩形ctx.fillRect(50, 25, 200, 65); // 该红色矩形浮在蓝色方框上面 (效果图) 11、图片 drawImage(): 将源图片(或源图片中的矩形区域中)的像素内容复制到画布上，有需要的时候可以对图片进行缩放和旋转 语法一：drawImage(img,x,y) 语法二：drawImage(img,x,y,width,height) 语法三：drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数说明: img: 图像、画布或视频 sx: 开始剪切的 x 坐标位置 sy: 开始剪切的 y 坐标位置 swidth: 被剪切图像的宽度 sheight: 被剪切图像的高度 x: 在画布上放置图像的 x 坐标位置 y: 在画布上放置图像的 y 坐标位置 width: 要使用的图像的宽度 height: 要使用的图像的高度 案例 12345678910111213ctx.moveTo(5, 5);ctx.lineTo(45, 45);ctx.lineWidth = 8;ctx.lineCap = 'round';ctx.stroke();ctx.translate(50, 100);ctx.rotate(-45 * Math.PI / 180); // 让线段变得更直ctx.scale(10, 10); // 将它放大到能够看到每个像素ctx.drawImage(ctx.canvas, 0, 0, 50, 50, // 源矩形区域 未变换 0, 0, 50, 50) // 目标矩形区域 变换过 (效果图) toDataUrl():画布自身的方法，将画布内容以png图片的形式返回，同时编码成一个字符串数据，用url表示，返回的url可以在&lt;img&gt;元素中使用，同时也可以实现画布静态截图的功能；此方法有一个很重要的安全限制，为了避免跨域的信息泄露，toDataURL()方法无法在非”origin-clean”的&lt;canvas&gt;上使用。123var img = document.createElement('img');img.src = canvas.toDataURL();document.body.appendChild(img); 12、合成（占坑）13、像素操作 getImageData(): 返回 ImageData 对象，该对象拷贝了画布指定矩形的像素数据,同样收同源安全策略的限制 putImageData(): 方法将图像数据（从指定的 ImageData 对象）放回画布上 示例(?)1234567891011121314151617181920212223242526272829303132333435363738// 使用ImageData实现动态模糊// 将矩形区域的像素向右进行涂抹// 来产生动态模糊效果，就好像物体正在从右向左移动// n必须要&gt;= 2， 该值越大，涂抹区域就越大// 矩形是在默认坐标中指定的function smear(c, n, x, y, w, h)&#123; // 获取表示矩形区域内像素的ImageData对象来实现涂抹效果 let pixels = c.getImageData(x, y, w, h); // 就地实现涂抹效果并只需要ImageData对象数据 // 一些图片处理算法要求额外的ImageData对象来存储变换后的像素值 // 如果需要输出缓冲区，可以以如下方式创建一个新的同样尺寸的ImageData对象 let output_pixels = c.createImageData(pixels); // 这些尺寸可能和w和h之类的参数不同，有可能是每个css像素要表示多个设备像素 let width = pixels.width, height = pixels.height; // data变量包含所有原始的像素信息，从左到右， 从上到下 // 每个像素按照RGBA的顺序共占据4个字节 let data = pixels.data; // 每一行的一个像素之后的像素都是通过将其色值替换成其色素值得1/0 + 原色素值的m/n let m = n - 1; for(let row = 0; row.height; row++)&#123; let i = row * width * 4 + 4; for(let col = 1; col &lt;width; col++, i+= 4)&#123; data[i] = (data[i] + data[i - 4] * m) / n; data[i + 1] = (data[i + 1] + data[i - 3] * m) / n; data[i + 2] = (data[i + 2] + data[i - 2] * m) / n; data[i + 3] = (data[i + 3] + data[i - 1] * m) / n; &#125; &#125; // 将涂抹过的图片数据复制回画布相同的位置 c.putImageData(pixels, x, y);&#125; 14、命中检测 isPointInPath(x, y): 确定一个指定的点是否落在(或者在边界上)当前路径中，返回true(落在当前路径中)|false(没落在当前路径中) 示例123456789101112131415161718192021// 如果鼠标事件发生指定的CanvasRenderingContext2D对象的当前路径上则返回truefunction hitpath(context, event)&#123; // 从&lt;canvas&gt;对象中获取&lt;canvas&gt;元素 let canvas = context.canvas; // 获取画布尺寸和位置 let bb = canvas.getBoundingClientRect(); // 将鼠标事件坐标通过转换和缩放变化成画布坐标 let x = (event.clientX - bb.left) * (canvas.width / bb.width); let y = (event.clientY - bb.top) * (canvas.height / bb.height); // 用这些变化后的坐标来调用isPointInPath()方法 return context.isPointInPath(x, y);&#125;canvas.onclick = function()&#123; if(hitpath(this.getContext('2d'), event)&#123; alert('Hit'); &#125;&#125; 以上源码地址(https://github.com/frontYang/study/tree/master/canvas/cases) 三、个人实践1、圆形占比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 绘制圆环占比 */// 圆形占比drawRound(&#123; id: 'j-round-config', data: &#123; name: '配置', width: 66, // 宽 height: 66, // 高 lineWidth: 3, // 边框宽 max: 100, // 满分 // cur: 88, // 当前值 per: 88, // 占比 state: 1 // 1:优秀 2: 良好, 3: 一般, 4:较差 &#125;&#125;)function drawRound(opts)&#123; let canvas = document.getElementById(opts.id); if(!canvas) return; let ctx = canvas.getContext('2d'), data = opts.data, width = data.width * 2, // 宽 height = data.height * 2, // 高 lineWidth = data.lineWidth * 2, // 环宽度 R = width / 2 - lineWidth / 2, // 半径 per = data.per, // 占比 bgColor = '#f4f4f8', // 背景环颜色 curColor = '#3496e9', ox = width / 2, // 圆心 X oy = height / 2; // 圆心 Y canvas.width = width; canvas.height = height; // 清除画布 let clear = function()&#123; ctx.clearRect(0, 0, width, height); &#125;, // 画底层圆弧 drawArcBg = function()&#123; ctx.beginPath(); ctx.lineCap = 'round'; ctx.arc(ox, oy, R, 0, 2 * Math.PI); ctx.lineWidth = lineWidth; ctx.strokeStyle = bgColor; ctx.stroke(); ctx.closePath(); &#125;, // 画高亮圆弧 drawArcCur = function()&#123; let rad = 2 * Math.PI / data.max; ctx.beginPath(); ctx.arc(ox, oy, R, 1.5 * Math.PI, 1.5 * Math.PI + per * rad); // 计算结束点弧度 ctx.lineWidth = lineWidth; ctx.strokeStyle = curColor; ctx.lineCap = 'round'; ctx.stroke(); ctx.closePath(); &#125;, // 填充文案 fillText = function()&#123; ctx.beginPath(); ctx.font = '20px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = '#999'; ctx.fillText(data.name, width / 2, height - 75); ctx.closePath(); ctx.beginPath(); let stateText = '', stateColor = ''; if(data.state == 1)&#123; stateText = '优秀'; // stateColor = '#f94e4e'; &#125;else if(data.state == 2)&#123; stateText = '良好'; // stateColor = '#ff8800'; &#125;else if(data.state == 3)&#123; stateText = '一般'; // stateColor = '#ffbb00'; &#125;else if(data.state == 4)&#123; stateText = '较差'; // stateColor = '#cccccc'; &#125; ctx.font = '26px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = '#333'; ctx.fillStyle = stateColor; ctx.fillText(stateText, width / 2, height - 35); ctx.closePath(); &#125;, draw = function()&#123; clear(); drawArcBg(); drawArcCur(); fillText(); &#125;; draw();&#125; (圆环) 2、仪表盘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// 绘制仪表图drawDashboard(&#123; id: 'j-dashboard', data: &#123; width: 236, // 宽 height: 141, // 高 lineWidth: 16, // 边框宽 max: 100, // 满分 cur: 88, // 当前值 per: 88, // 占比 state: 1 // 1: 烈推荐,2: 值得推荐, 3: 一般推荐, 4:不太推荐 &#125;&#125;)/* 绘制仪表图 */function drawDashboard(opts)&#123; let canvas = document.getElementById(opts.id); if(!canvas) return; let ctx = canvas.getContext('2d'), data = opts.data, width = data.width * 2, // 宽 height = data.height * 2, // 高 lineWidth = data.lineWidth * 2, // 环宽度 R = width / 2 - lineWidth / 2, // 半径 otherHeight = width / 2 - height / 2, // 半圆多余的高度 per = data.per, // 占比 bgColor = '#e6f2fe', // 背景环颜色 curStartColor = '#52bff9', curEndColor = '#0780e1', scaleColor = '#b8deee', // 刻度颜色 ox = R + lineWidth / 2, // 圆心 X oy = height + lineWidth / 2 - otherHeight / 2; // 圆心 Y canvas.width = width; canvas.height = height; // 清除画布 let clear = function()&#123; ctx.clearRect(0, 0, width, height); &#125;, // 画底层圆弧 drawArcBg = function()&#123; ctx.beginPath(); ctx.lineCap = 'round'; ctx.arc(ox, oy, R, 0.8 * Math.PI, 0.2 * Math.PI); // ctx.arc(ox, oy, R, 1 * Math.PI, 0 * Math.PI); ctx.lineWidth = lineWidth; ctx.strokeStyle = bgColor; ctx.stroke(); ctx.closePath(); &#125;, // 画高亮圆弧 drawArcCur = function()&#123; let rad = Math.PI / data.max; ctx.beginPath(); ctx.arc(ox, oy, R, 0.8 * Math.PI, Math.PI + per * rad); // 计算结束点弧度 // ctx.arc(ox, oy, R, 1 * Math.PI, Math.PI + per * rad); // 计算结束点弧度 ctx.lineWidth = lineWidth; ctx.strokeStyle = curEndColor; ctx.lineCap = 'round'; ctx.stroke(); ctx.closePath(); &#125;, // 画刻度 drawArcScale = function()&#123; let scaleLen = 23, // 刻度数 ?? 只画了16个 padding = lineWidth / 2 + 12 * 2 , // 距圆环距离 R1 = (width / 2) - padding, // 半径 smallWidth = 10, // 小刻度宽 largeWidth = 20 // 大刻度宽 for (let i = 1; i &lt;= scaleLen * 2; i++) &#123; ctx.beginPath(); let rad = Math.PI + Math.PI / scaleLen * (i - 1), x1 = ox + Math.sin(rad) * R1, y1 = oy - Math.cos(rad) * R1, x2, y2; ctx.moveTo(x1, y1); if(i == 1 || i == scaleLen * 2) &#123; ctx.strokeStyle = '#000'; &#125;else &#123; ctx.strokeStyle = scaleColor; &#125; ctx.lineWidth = 2; if(i % 2 == 0)&#123; // 偶數 长刻度 x2 = ox + Math.sin(rad) * (R1 - largeWidth); y2 = oy - Math.cos(rad) * (R1 - largeWidth); &#125;else&#123; // 奇数 短刻度 x2 = ox + Math.sin(rad) * (R1 - smallWidth); y2 = oy - Math.cos(rad) * (R1 - smallWidth); &#125; ctx.lineTo(x2 , y2); ctx.stroke(); ctx.closePath(); &#125; &#125;, // 填充文案 fillText = function()&#123; ctx.beginPath(); ctx.font = 'bold 80px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillText(data.cur, width / 2, height - 100); ctx.closePath(); ctx.beginPath(); ctx.font = '24px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = '#999'; ctx.fillText(`满分$&#123;data.max&#125;`, width / 2, height - 60); ctx.closePath(); ctx.beginPath(); let stateText = '', stateColor = ''; if(data.state == 1)&#123; stateText = '强烈推荐'; stateColor = '#f94e4e'; &#125;else if(data.state == 2)&#123; stateText = '值得推荐'; stateColor = '#ff8800'; &#125;else if(data.state == 3)&#123; stateText = '一般推荐'; stateColor = '#ffbb00'; &#125;else if(data.state == 4)&#123; stateText = '不太推荐'; stateColor = '#cccccc'; &#125; ctx.font = '36px Microsoft Yahei'; ctx.textAlign = 'center'; ctx.fillStyle = stateColor; ctx.fillText(stateText, width / 2, height - 15); ctx.closePath(); &#125;, draw = function()&#123; clear(); drawArcBg(); drawArcCur(); drawArcScale(); fillText(); &#125;; draw();&#125; (效果图) 3、折线图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// 画折线图drawLineChart(&#123; id: 'j-chart-line', data: &#123; width: 351, height: 212, xAxis: ['1年', '2年', '3年', '4年', '5年'], //X 轴文案 yAxis: ['100%', '80%', '60%', '40%', '30%', '0%'], // y轴文案 yData: ['80%', '60%', '40%', '20%', '30%'] // y轴数据 &#125;&#125;)/* 绘制折线图 */function drawLineChart(opts)&#123; let canvas = document.getElementById(opts.id) if(!canvas) return; let ctx = canvas.getContext('2d'), data = opts.data, width = data.width * 2, height = data.height * 2, xArr = [], yArr = [], yPerWidth = 82, // y轴文案宽度 yWidth = width - yPerWidth, // y轴宽度 yHeight = 60, // y轴间距 xWidth = yWidth / data.xAxis.length, // 每个 x 宽度 lineColor = '#007adf', // 折线颜色 axisColor = '#eee' // 轴线颜色 // 设置宽高 canvas.width = width; canvas.height = height; ctx.font = '24px Microsoft Yahei'; /** * 画圆点 * @param &#123;object&#125; ctx canvas绘图环境 * @param &#123;object&#125; opt x,y起始点; r半径 */ let drawPoint = function(ctx, opt)&#123; ctx.arc(opt.x, opt.y, opt.r, 0, 2 * Math.PI, Math.PI, false); ctx.fillStyle = opt.color; ctx.fill(); ctx.closePath(); &#125;, /** * 画折线 * @param &#123;object&#125; ctx canvas绘图环境 * @param &#123;object&#125; opt x0,y0起始点; x1,y1结束点 */ drawLine = function(ctx, opt)&#123; ctx.beginPath(); ctx.moveTo(opt.x0, opt.y0); ctx.lineTo(opt.x1, opt.y1); ctx.strokeStyle = opt.color; ctx.stroke(); ctx.closePath(); &#125;, // 画X轴 drawX = function()&#123; ctx.beginPath(); // 第一个刻度 ctx.moveTo(yPerWidth, height - yHeight - 10); ctx.lineTo(yPerWidth, height - yHeight - 20); ctx.textAlign = 'center'; ctx.lineWidth = 2; ctx.strokeStyle = axisColor; // 其余刻度 for (let i = 0; i &lt; data.xAxis.length; i++) &#123; ctx.moveTo(yPerWidth + xWidth * (i + 1), height - yHeight - 10); ctx.lineTo(yPerWidth + xWidth * (i + 1), height - yHeight - 20); ctx.fillText(data.xAxis[i], xWidth * (i + 1) + 24, yHeight * data.yAxis.length + 24); ctx.fill(); ctx.stroke(); ctx.closePath(); &#125; &#125;, // 画Y轴 drawY = function()&#123; ctx.beginPath(); for (let i = 0; i &lt; data.yAxis.length; i++) &#123; ctx.fillText(data.yAxis[i], 0, yHeight * (i + 1), yPerWidth); ctx.moveTo(yPerWidth, yHeight * (i + 1) - 8); ctx.lineTo(width, yHeight * (i + 1) - 8); ctx.lineWidth = 2; ctx.strokeStyle = axisColor; ctx.fill(); ctx.stroke(); ctx.closePath(); &#125; &#125;, drawCurLine = function()&#123; let H = yHeight * 5; let R = 6; ctx.fillStyle = lineColor; ctx.moveTo(yPerWidth, yHeight); for (let i = 0; i &lt; data.yData.length; i++) &#123; let perH = data.yData[i].replace(/%/, '') / 100 * H ctx.beginPath(); ctx.arc(xWidth * (i + 1) - R / 2, H - perH + yHeight - R, R, 0, 2 * Math.PI, false); ctx.fillStyle = lineColor; ctx.fill(); if(i &lt;= data.yData.length - 2)&#123; perH = data.yData[i + 1].replace(/%/, '') / 100 * H; ctx.lineTo(xWidth * (i + 2) - R / 2, H - perH + yHeight - R) &#125; ctx.strokeStyle = lineColor; ctx.stroke(); ctx.closePath(); &#125; &#125;, draw = function()&#123; drawY(); drawX(); drawCurLine(); &#125; draw();&#125; (效果图) 以上源码地址(https://github.com/frontYang/lib/chartUtil)(未完。。。)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp学习笔记]]></title>
    <url>%2F2018%2F03%2F17%2Fgulp%2F</url>
    <content type="text"><![CDATA[一、安装 yarn global add gulp 运行：gulp tast名 项目目录结构(示例) 12345678910111213141516171819202122232425262728293031323334353637383940+ src(项目原目录) * images(图片) - icon(需要生成精灵图的图片) + icon1.png + icon2.png - pic.png * js(页面js) - block(公共js) + common.js + util.js - index.js * css(页面css) - block(公共css) + reset.scss + header.scss - index.scss * components(公共模块) - header.html - footer.html * index.html+ dist(生成目录，不需创建) * images - sprite.png - pic.png * js - block + common.js + util.js - index.js * css - block + reset.css + header.scss + sprites.css - index.css * index.html+ node_modules(node模块，不需创建)+ gulpfile.js(gulp配置js)+ package.json+ yarn.lock 二、部分插件的安装和使用1、browser-sync：自动刷新 安装： yarn add browser-sync123456789const browserSync = require('browser-sync');gulp.task('browserSync', function()&#123; browserSync(&#123; server: &#123; baseDir: 'dist' &#125; &#125;)&#125;) 2、处理css相关插件 安装： yarn add gulp-sass gulp-postcss autoprefixer del-gulpsass-blank-lines123456789101112131415const sass = require('gulp-sass'); // 编译Sassconst postcss = require('gulp-postcss'); // 后处理器const autoprefixer = require('autoprefixer'); // 加前缀，与postcss配合使用const dgbl = require("del-gulpsass-blank-lines"); // 删掉sass空行gulp.task('sass', function()&#123; return gulp.src('src/css/**/*.scss') .pipe(sass(&#123;outputStyle: 'compact'&#125;).on('error', sass.logError)) .pipe(dgbl()) .pipe(postcss([autoprefixer(&#123;browsers: ['last 2 versions', 'Android &gt; 4.4','iOS &gt;= 8', 'Firefox &gt;= 20']&#125;)])) .pipe(gulp.dest('dist/css')) .pipe(browserSync.reload(&#123; // 只有被改变的地方局部刷新 stream: true &#125;))&#125;) 3、gulp-babel：es6转es5 安装： yarn add gulp-babel1234567891011const babel = require('gulp-babel'); // bablegulp.task('babel', function()&#123; return gulp.src('src/js/**/*.js') .pipe(babel(&#123; presets: ['@babel/env'], plugins: ['@babel/transform-runtime'] &#125;)) // .pipe(uglify()) .pipe(gulp.dest('dist/js'))&#125;) 4、处理图片 安装： yarn add gulp-imagemin gulp.spritesmith gulp-cache1234567891011121314151617181920212223242526272829303132333435363738394041const imagemin = require('gulp-imagemin'); // 优化图片const spritesmith = require('gulp.spritesmith'); // 图片精灵const cache = require('gulp-cache'); // 缓存代理任务。，减少图片重复压缩gulp.task('images', function() &#123; return gulp.src('src/images/icon/*.png') // Caching images that ran through imagemin .pipe(cache(imagemin(&#123; interlaced: true, &#125;))) .pipe(spritesmith(&#123; imgName:'images/sprite.png', //合并后大图的名称 cssName:'css/block/sprite.css', padding:2// 每个图片之间的间距，默认为0px // cssTemplate:(data)=&gt;&#123; // 可以自定义输出格式 // // data为对象，保存合成前小图和合成打大图的信息包括小图在大图之中的信息 // let arr = [], // width = data.spritesheet.px.width, // height = data.spritesheet.px.height, // url = data.spritesheet.image // // console.log(data) // data.sprites.forEach(function(sprite) &#123; // arr.push( // '.icon-'+sprite.name+ // '&#123;'+ // 'background: url('+url+') '+ // 'no-repeat '+ // sprite.px.offset_x+' '+sprite.px.offset_y+';'+ // 'background-size: '+ width+' '+height+';'+ // 'width: '+sprite.px.width+';'+ // 'height: '+sprite.px.height+';'+ // '&#125;\n' // ) // &#125;) // // return "@fs:108rem;\n"+arr.join("") // return arr.join('') // &#125; &#125;)) .pipe(gulp.dest('dist/'))&#125;); 5、gulp-content-includer： include 公共模块 安装： yarn add gulp-content-includer1234567891011const contentIncluder = require('gulp-content-includer');gulp.task('concat',function() &#123; gulp.src('src/*.html') .pipe(contentIncluder(&#123; // 可以自定义 includerReg:/&lt;!\-\-\#include\s+virtual="([^"]+)"\-\-&gt;/g &#125;)) .pipe(gulp.dest('dist/'))&#125;);// 可以使用 &lt;!--#include virtual="./components/header.html"--&gt; 方式来引入公共模块 6、清理生成文件 安装： yarn add del12345678910111213const del = require('del'); // 清理生成文件// 删除 除了images/文件夹，dist下的任意文件gulp.task('clean:dist', function() &#123; return del.sync(['dist/**/*', '!dist/images', '!dist/images/**/*']);&#125;);// 在某些时候我们还是需要清除图片，所以clean任务我们还需要保留gulp.task('clean', function() &#123; return del.sync('dist').then(function(cb) &#123; return cache.clearAll(cb); &#125;);&#125;) 7、组合任务 安装： yarn add run-sequence1234567891011121314151617181920212223const runSequence = require('run-sequence'); // 按照指定顺序运行任务// 监听文件，刷新浏览器gulp.task('watch', function() &#123; gulp.watch('src/scss/**/*.scss', ['sass']); gulp.watch('src/**/*.html', browserSync.reload); gulp.watch('src/js/**/*.js', browserSync.reload);&#125;)// 按顺序执行任务，放 [] 内的任务会同时执行gulp.task('build', function(callback) &#123; runSequence( 'clean:dist', ['sass','babel','concat','images'], callback )&#125;)gulp.task('default', function(callback) &#123; runSequence(['sass', 'babel', 'browserSync', 'concat', 'images'], 'watch', callback )&#125;) 参考连接仓库地址]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe跨域问题]]></title>
    <url>%2F2018%2F03%2F11%2Fiframe%2F</url>
    <content type="text"><![CDATA[一、主域相同 子页面和父页面都加上 document.domain = &quot;子页面域名&quot; 二、跨全域高度自适应1、postMessage(不兼容ie8-) 父页面 1234567891011121314&lt;iframe onload="resizeCrossDomainIframe('iframepage', '子页面域名');" src="父页面")function resizeCrossDomainIframe(id, other_domain) &#123; var iframe = document.getElementById(id); window.addEventListener('message', function(event) &#123; if (event.origin !== other_domain) return; // only accept messages from the specified domain if (isNaN(event.data)) return; // only accept something which can be parsed as a number var height = parseInt(event.data) + 32; // add some extra height to avoid scrollbar iframe.height = height + "px"; &#125;, false);&#125; 子页面 1&lt;body onload="parent.postMessage(document.body.scrollHeight, '父页面域名');"&gt; 2、使用代理页面 父页面 1&lt;iframe id="parentPage" name="mainFrame" scrolling="no" src="子页面" frameborder="0" width="100%"&gt;&lt;/iframe&gt; 代理页面(与父页面同域名) 12345678910&lt;script&gt;var b_iframe = window.parent.parent.document.getElementById("parentPage");var hash_url = window.location.hash;if (hash_url.indexOf("#") &gt;= 0) &#123; var hash_width = hash_url.split("#")[1].split("|")[0] + "px"; var hash_height = hash_url.split("#")[1].split("|")[1] + "px"; b_iframe.style.width = hash_width; b_iframe.style.height = hash_height;&#125;&lt;/script&gt; 子页面 123456789&lt;iframe id="agentPage" height="0" width="0" src="中间页面" style="display:none"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt;(function autoHeight() &#123; var b_width = Math.max(document.body.scrollWidth, document.body.clientWidth); var b_height = Math.max(document.body.scrollHeight, document.body.clientHeight); var c_iframe = document.getElementById("agentPage"); c_iframe.src = c_iframe.src + "#" + b_width + "|" + b_height;&#125;)();&lt;/script&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用css收集]]></title>
    <url>%2F2018%2F03%2F11%2Fcss%2F</url>
    <content type="text"><![CDATA[一、 reset 1234567891011121314151617181920212223@charset 'utf-8';@charset "GBK";*&#123;margin:0;padding:0; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none;-webkit-text-size-adjust:none; &#125;*:focus,*:active &#123;outline:none;&#125;html, body &#123; height:100%;&#125;body&#123; width: 100%;font-family: \5FAE\8F6F\96C5\9ED1,\5B8B\4F53;-webkit-user-select:none;&#125;p,a,span,textarea,b,input,dt,dd &#123; color: #666;font-size: 0.9rem;&#125;ul, ol&#123;list-style:none;&#125;img&#123;border:none;&#125;a &#123; text-decoration:none;&#125;textarea &#123;resize:none;&#125;input[type=button],button&#123;text-align: center; background: none; border: 0; outline: none; &#125;input &#123; background: white; border: none; outline: none;&#125;/*占位符颜色*/input::-webkit-input-placeholder, textarea::-webkit-input-placeholder &#123; color:#ccc; &#125;input:-moz-placeholder, textarea:-moz-placeholder &#123; color:#ccc; &#125;input::-moz-placeholder, textarea::-moz-placeholder &#123; color: #ccc; &#125;input:-ms-input-placeholder, textarea:-ms-input-placeholder &#123; color: #ccc; &#125;/*占位符点击消失*/input:focus::-webkit-input-placeholder&#123;text-indent: -999em; z-index: -20; &#125; 二、function1234567891011/* 浮动 */.fl &#123; float: left !important; &#125;.fr &#123; float: right !important; &#125;.clear &#123; clear: both; &#125;/* 功能 */.hide &#123; display:none !important; &#125;/*隐藏*/.ellipsis1 &#123; overflow:hidden;-o-text-overflow:ellipsis;text-overflow:ellipsis;white-space:nowrap;word-break:keep-all; &#125; /* 字数省略 */.ellipsis2 &#123;display: -webkit-box; -webkit-line-clamp:2; overflow: hidden; -webkit-box-orient: vertical; text-overflow: ellipsis;&#125; /* 两行字数省略 */.keep &#123; position:fixed !important;border-bottom: #ccc 1px solid !important; &#125; /*滚动保持*/.mask &#123;display: none;position: fixed;left: 0;z-index: 11;width: 100%; height: 100%;background-color:rgba(0, 0, 0, 0.4);&#125;/*遮罩层*/ 三、skin12345678/* 效果 */.shadow,.all-shadow * &#123;box-shadow: 0 0 .3rem #ddd !important;&#125;.gradient,.all-gradient * &#123;background: -webkit-linear-gradient(top, #fff4f4,#fff);&#125;.radius,.all-radius * &#123; border-radius: .2em;&#125;.left-radius &#123;border-top-left-radius: .2em;border-bottom-left-radius: .2em;&#125;.right-radius &#123;border-top-right-radius: .2em;border-bottom-right-radius: .2em;&#125;.top-radius &#123;border-top-left-radius: .2em;border-top-right-radius: .2em;&#125;.alpha&#123;filter:alpha(opacity=50); -moz-opacity:0.5; -khtml-opacity: 0.5; opacity: 0.5;&#125; 四、arrow12345678910111213141516171819202122232425262728293031323334353637383940414243/* 纯css实现箭头样式 u:上 r:右 d:下 l:左; S*//** * 实心箭头 */.icon-arrA&#123;display: inline-block;/* ie7下需要 加上inline-block 才生效,ie6不支持*/ font-size: 0; line-height: 0; overflow: hidden; &#125;.icon-arrA-u&#123;border-width: 8px; border-style: solid; border-color: transparent transparent #e6e6e6 transparent; &#125;.icon-arrA-d&#123;border-width: 8px; border-style: solid; border-color: #e6e6e6 transparent transparent transparent; &#125;.icon-arrA-l&#123;border-width: 8px; border-style: solid; border-color: transparent #e6e6e6 transparent transparent; &#125;.icon-arrA-r&#123;border-width: 8px; border-style: solid; border-color: transparent transparent transparent #e6e6e6; &#125;/** * 边框箭头 兼容webkit */.icon-arrB&#123;display: inline-block; width: 8px; height: 8px; font-size: 0; overflow: hidden; background-color: transparent; border-width: 2px 2px 0 0; border-style: solid; border-color: #e6e6e6; &#125;.icon-arrB-u&#123;-webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); transform: rotate(-45deg); &#125;.icon-arrB-d&#123;-webkit-transform: rotate(135deg); -moz-transform: rotate(135deg); -ms-transform: rotate(135deg); transform: rotate(135deg); &#125;.icon-arrB-l&#123;-webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); transform: rotate(45deg); &#125;.icon-arrB-r&#123;-webkit-transform: rotate(-135deg); -moz-transform: rotate(-135deg); -ms-transform: rotate(-135deg); transform: rotate(45deg); &#125;/** * 边框箭头：兼容 ie（不包括ie6） */.arr-wrap&#123;display: inline-block; position: relative; &#125;.arr-wrap .icon-arrA&#123;position: absolute; left: 0; &#125;.arr-wrap .s1.icon-arrA-u, .arr-wrap .s1.icon-arrA-r, .arr-wrap .s1.icon-arrA-d, .arr-wrap .s1.icon-arrA-l&#123;z-index: 1; &#125;.arr-wrap .s1.icon-arrA-u, .arr-wrap .s2.icon-arrA-d&#123;top: 2px; &#125;.arr-wrap .s2.icon-arrA-u, .arr-wrap .s1.icon-arrA-d&#123;top: 0; &#125;.arr-wrap .s2.icon-arrA-u, .arr-wrap .s2.icon-arrA-r, .arr-wrap .s2.icon-arrA-d, .arr-wrap .s2.icon-arrA-l&#123;z-index: 0; &#125;.arr-wrap .s1.icon-arrA-r, .arr-wrap .s2.icon-arrA-l&#123;left: 0; &#125;.arr-wrap .s2.icon-arrA-r, .arr-wrap .s1.icon-arrA-l&#123;left: 2px; &#125;.arr-wrap .s1.icon-arrA-u&#123;border-bottom-color: #fff; &#125;.arr-wrap .s2.icon-arrA-u&#123;border-bottom-color: #e6e6e6; &#125;.arr-wrap .s1.icon-arrA-r&#123;border-left-color: #fff; &#125;.arr-wrap .s2.icon-arrA-r&#123;border-left-color: #e6e6e6; &#125;.arr-wrap .s1.icon-arrA-d&#123;border-top-color: #fff; &#125;.arr-wrap .s2.icon-arrA-d&#123;border-top-color: #ddd; &#125;.arr-wrap .s1.icon-arrA-l&#123;border-right-color: #fff; &#125;.arr-wrap .s2.icon-arrA-l&#123;border-right-color: #e6e6e6; &#125;/* 箭头边框阴影 */.arr-wrap-su&#123;width: 20px;height: 20px;&#125;.arr-wrap-su::after&#123;content: ''; position: absolute; z-index: -1; width: 8px; height: 8px; background: #fff; left: 4px; top: 12px; border-width: 1px 1px 0 0; border-style: solid; border-color: #e6e6e6; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); transform: rotate(-45deg); box-shadow: 2px -2px 5px #e6e6e6; -webkit-box-shadow: 2px -2px 5px #e6e6e6; -moz-box-shadow: 2px -2px 5px #e6e6e6; &#125;/* 纯css实现箭头样式 E*/ 五、ie6兼容问题 链接伪类（:hover）CSS背景图片有闪动 1&lt;!--[if IE 6]&gt;&lt;script&gt;document.execCommand("BackgroundImageCache", false, true)&lt;/script&gt;&lt;![endif]--&gt; border兼容transparent 1_border-color:tomato;_filter:chroma(color=tomato); 兼容fixed 1.fixed&#123;position:fixed; top:35%; right:0; _position:absolute; _top:expression(offsetParent.scrollTop+100); _right:expression(offsetParent.scrollRight);&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F03%2F11%2Fgitskill%2F</url>
    <content type="text"><![CDATA[一、创建版本库 初始化一个Git仓库，使用 git init 命令 添加文件到仓库: 第一步：使用命令 git add [file]，可以反复多次使用，添加多个文件 第二步：使用命令 git commit 二、查看仓库目前状态 git status:掌握工作区的状态,查看文件是否被修改过(但还没有准备提交的修改) git diff:可以查看修改内容 三、版本回退 HEAD指向的版本就是当前版本，git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id git log查看提交历史，以便会退到哪个版本 git reflog查看命令历史，以便确定要回到未来哪个版本 四、撤销修改 git checkout -- file:直接丢弃工作区的修改 丢弃暂存区的修改:用git reset HEAD file回到上一步 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库 五、删除文件 第一步：git rm [file] 第二步：git commit 六、添加远程库 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git 关联后，使用命令git push -u origin master第一次推送master分支的所有内容 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 ps:由于公司防火墙通过ssh不能连接github，需要设置http代理来连接 设置代理：git config --global http.proxy 192.168.xx.xxx:xxxx 移除代理：git config --system --unset http.proxy 七、从远程库克隆 git clone https://github.com/xx/xx.git 八、分支管理 查看分支:git branch 创建分支：git branch [name] 切换分支：git checkout [name] 创建+切换分支：git checkout -b [name] 合并某分支到当前分支：git merge [name] 删除分支：git branch -d [name] 九、修改文件后提交 并提交到github 步骤： 创建并切换分支: git checkout -b [name] 添加修改过的文件: git add [file] 提交文件: git commit -m &quot;描述&quot; 切换到master分支: git checkout [name] 合并修改文件的分支到当前分支: git merge [name] 删除修改文件的分支: git branch -d [name] 提交到远程库: git push origin master 参考]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript常用方法收集]]></title>
    <url>%2F2018%2F03%2F11%2Fjavascript-function%2F</url>
    <content type="text"><![CDATA[一、获取id和ClassName1234567891011121314151617181920212223242526272829303132333435363738394041//获取idfunction getId(id) &#123; return (typeof id == "object") ? id : document.getElementById(id);&#125;//获取ClassNamefunction getElementsByClassName(name) &#123; var tags = document.getElementsByTagName('*') || document.all; var els = []; for (var i = 0; i &lt; tags.length; i++) &#123; if (tags.className) &#123; var cs = tags.className.split(' '); for (var j = 0; j &lt; cs.length; j++) &#123; if (name == cs[j]) &#123; els.push(tags); break &#125; &#125; &#125; &#125; return els&#125;//解决IE8之类不支持getElementsByClassNameif (!document.getElementsByClassName) &#123; document.getElementsByClassName = function(className, element) &#123; var children = (element || document).getElementsByTagName('*'); var elements = new Array(); for (var i = 0; i &lt; children.length; i++) &#123; var child = children[i]; var classNames = child.className.split(' '); for (var j = 0; j &lt; classNames.length; j++) &#123; if (classNames[j] == className) &#123; elements.push(child); break; &#125; &#125; &#125; return elements; &#125;;&#125; 二、获取页面常用高度及兼容1234567891011121314// 浏览器窗口可视区域大小（不包括工具栏和滚动条等边线）var client_w = document.documentElement.clientWidth || document.body.clientWidth;var client_h = document.documentElement.clientHeight || document.body.clientHeight;// 网页内容实际宽高（包括工具栏和滚动条等边线）var scroll_w = document.documentElement.scrollWidth || document.body.scrollWidth;var scroll_h = document.documentElement.scrollHeight || document.body.scrollHeight;// 网页内容实际宽高 (不包括工具栏和滚动条等边线）var offset_w = document.documentElement.offsetWidth || document.body.offsetWidth;var offset_h = document.documentElement.offsetHeight || document.body.offsetHeight;// 滚动的高度var scroll_Top = document.documentElement.scrollTop||document.body.scrollTop; 三、时间个性化输出1234567891011121314151617181920212223242526272829303132333435363738394041//时间个性化输出/*1、&lt; 60s, 显示为“刚刚”2、&gt;= 1min &amp;&amp; &lt; 60 min, 显示与当前时间差“XX分钟前”3、&gt;= 60min &amp;&amp; &lt; 1day, 显示与当前时间差“今天 XX:XX”4、&gt;= 1day &amp;&amp; &lt; 1year, 显示日期“XX月XX日 XX:XX”5、&gt;= 1year, 显示具体日期“XXXX年XX月XX日 XX:XX”*/function timeFormat(time)&#123; var date = new Date(time), curDate = new Date(), year = date.getFullYear(), month = date.getMonth() + 10, day = date.getDate(), hour = date.getHours(), minute = date.getMinutes(), curYear = curDate.getFullYear(), curHour = curDate.getHours(), timeStr; if(year &lt; curYear)&#123; timeStr = year +'年'+ month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else&#123; var pastTime = curDate - date, pastH = pastTime/3600000; if(pastH &gt; curHour)&#123; timeStr = month +'月'+ day +'日 '+ hour +':'+ minute; &#125;else if(pastH &gt;= 1)&#123; timeStr = '今天 ' + hour +':'+ minute +'分'; &#125;else&#123; var pastM = curDate.getMinutes() - minute; if(pastM &gt; 1)&#123; timeStr = pastM +'分钟前'; &#125;else&#123; timeStr = '刚刚'; &#125; &#125; &#125; return timeStr;&#125; 四、返回顶部的通用方法123456789101112131415161718192021//返回顶部的通用方法function backTop(btnId) &#123; var btn = document.getElementById(btnId); var d = document.documentElement; var b = document.body; window.onscroll = set; btn.style.display = 'none'; btn.onclick = function() &#123; btn.style.display = 'none'; window.onscroll = null; this.timer = setInterval(function() &#123; d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1); if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set); &#125;, 10); &#125;; function set() &#123; btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? 'block': 'none' &#125;&#125;;backTop('goTop'); 五、事件委托1234567891011121314151617//关于编写性能高效的javascript事件的技术&lt;input type="button" id="btn" name="btn" value="BUTTON"/&gt;&lt;a href="#" id="aa"&gt;aa&lt;/a&gt;&lt;script&gt;document.addEventListener("click",function(evt)&#123; var target = evt.target; switch(target.id)&#123; case "btn": alert("button"); break; case "aa": alert("a"); break; &#125;&#125;,false);&lt;/script&gt; 六、倒计时1234567891011121314151617181920212223242526272829303132333435363738/** * 活动倒计时 * @param &#123;string&#125; expiry endtine * @param &#123;object&#125; obj element */function getTime(expiry,obj) &#123; if(expiry == "" || !obj)&#123;return;&#125; var now = new Date(); var expiry = expiry; var a = now.getFullYear() + '.' + (now.getMonth()+1) + '.' + now.getDate() +' ' + now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds(); var b = expiry; var startTime = new Date(a); var endTime = new Date(b); if ( endTime &lt;= now) &#123; obj.innerHTML = "距离活动开始还有&lt;i class='s-blue'&gt;00&lt;/i&gt;天&lt;i class='s-blue'&gt;00&lt;/i&gt;时&lt;i class='s-blue'&gt;00&lt;/i&gt;分&lt;i class='s-blue'&gt;00&lt;/i&gt;秒"; &#125; else &#123; var days = (endTime - now) / 1000 / 60 / 60 / 24; var daysRound = checkTime(Math.floor(days)); var hours = (endTime - now) / 1000 / 60 / 60 - (24 * daysRound); var hoursRound = checkTime(Math.floor(hours)); var minutes = (endTime - now) / 1000 / 60 - (24 * 60 * daysRound) - (60 * hoursRound); var minutesRound = checkTime(Math.floor(minutes)); var seconds = (endTime - now) / 1000 - (24 * 60 * 60 * daysRound) - (60 * 60 * hoursRound) - (60 * minutesRound); var secondsRound = checkTime(Math.round(seconds)); obj.innerHTML = '距离活动开始还有:&lt;i class="s-blue"&gt;'+ daysRound +'&lt;/i&gt;天&lt;i class="s-blue"&gt;'+ hoursRound +'&lt;/i&gt;时&lt;i class="s-blue"&gt;'+ minutesRound +'&lt;/i&gt;分&lt;i class="s-blue"&gt;'+ secondsRound +'&lt;/i&gt;秒'; function _getTime(expiry)&#123; return function()&#123; getTime(expiry,obj) &#125; &#125; newtime = window.setTimeout(_getTime(expiry,obj), 1000); &#125;&#125; 七、常用正则表达式 正整数: /^[0-9]*[1-9][0-9]*$/ 负整数: /^-[0-9]*[1-9][0-9]*$/ 正浮点数: /^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/ 负浮点数: /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/ 浮点数: /^(-?\d+)(\.\d+)?$/ email地址: /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/ url地址: /^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$/ 年/月/日（年-月-日、年.月.日）:/^(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/ 匹配中文字符: /[\u4e00-\u9fa5]/ 匹配空白行: /\n\s*\r/ 匹配中国邮政编码: /[1-9]\d{5}(?!\d)/ 匹配身份证(只是对格式进行检验)：/\d{15}|\d{18}/ 匹配国内电话号码：/(\d{3}-|\d{4}-)?(\d{8}|\d{7})?/ 匹配首尾空白字符: /^\s*|\s*$/ 匹配HTML标记：/&lt; (\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;/ 腾讯 QQ 号: /^[1-9]*[1-9][0-9]*$/ 中文、英文、数字及下划线: /^[\u4e00-\u9fa5_a-zA-Z0-9]+$/ 八、增删class12345678910111213141516//判断是否有这个classfunction hasClass( elements,cName )&#123; return !!elements.className.match( new RegExp( "(\\s|^)" + cName + "(\\s|$)") );&#125;;//添加classfunction addClass( elements,cName )&#123; if( !hasClass( elements,cName ) )&#123; elements.className += " " + cName; &#125;;&#125;;//移除classfunction removeClass( elements,cName )&#123; if( hasClass( elements,cName ) )&#123; elements.className = elements.className.replace( new RegExp( "(\\s|^)" + cName + "(\\s|$)" ), " " ); &#125;;&#125;; 九、封装cookie组件12345678910111213141516171819202122232425262728293031323334var Cookie = &#123; // 读取 get: function(name)&#123; var cookieStr = "; "+document.cookie+"; "; var index = cookieStr.indexOf("; "+name+"="); if (index!=-1)&#123; var s = cookieStr.substring(index+name.length+3,cookieStr.length); return unescape(s.substring(0, s.indexOf("; "))); &#125;else&#123; return null; &#125; &#125;, // 设置 set : function(name,value,expires)&#123; var expDays = expires*24*60*60*1000; var expDate = new Date(); expDate.setTime(expDate.getTime()+expDays); var expString = expires ? "expires="+expDate.toGMTString() : ""; var pathString = ";path=/"; document.cookie = name + "=" + escape(value) + expString + pathString; &#125;, // 删除 del : function(name)&#123; var exp = new Date(new Date().getTime()-1); var s=this.read(name); if(s!=null) &#123; document.cookie= name + "="+s+"expires="+exp.toGMTString()+";path=/" &#125; &#125;&#125;;// demo:Cookie.set("xxx", "xx", 7);alert(Cookie.get("xxx"));Cookie.del("xxx"); 十、类型转换函数123456789101112131415161718192021222324252627var Converter = &#123; toDate: function(strDate)&#123; var sDate = strDate.replace(/(^\s+|\s+$)/g,''); //去两边空格; if(sDate=='')&#123; return null; &#125; var s = sDate.replace(/[\d]&#123;4,4&#125;[\-/]&#123;1&#125;[\d]&#123;1,2&#125;[\-/]&#123;1&#125;[\d]&#123;1,2&#125;/g, ''); if (s == '') &#123; var t=new Date(sDate.replace(/\-/g,'/')); var ar = sDate.split(/[-/:]/); if(ar[0] == t.getFullYear() &amp;&amp; ar[1] == t.getMonth() + 1 &amp;&amp; ar[2] == t.getDate()) &#123; return t; //返回转化成功的日期对象 &#125; &#125; return null; &#125;&#125;;console.log(Converter.toDate("2014/9/2"));console.log(Converter.toDate("2014-9-2"));console.log(Converter.toDate("2014-09-02"));// Tue Sep 02 2014 00:00:00 GMT+0800 (中国标准时间) 十一、动态脚本元素12345678910111213141516171819/** * 加载JS文件 * @param &#123;string&#125; url 资源url * @param &#123;function&#125; callback 回调函数 * @param &#123;string&#125; charset 资源编码 */function loadScript(url, callback, charset) &#123; var oscript = document.createElement('script'); if(charset) oscript.charset = charset; oscript.src = url; oscript.onload = oscript.onreadystatechange = function() &#123; if (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete') &#123; oscript.onload = oscript.onreadystatechange = null; callback &amp;&amp; callback(); oscript.parentNode.removeChild(oscript); &#125; &#125;; document.body.insertBefore(oscript, document.body.firstChild);&#125; 十二、js数组去重1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var Unique = &#123; /** * 双重循环去重（经过测试超过两个重复的会留下两个） * @param arr * @returns &#123;*&#125; */ dbloop: function (arr) &#123; var i, j, res = []; for (i = 0; i &lt; arr.length; i++) &#123; for (j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(i, 1);//当出现相同的元素时，删除重复的元素 &#125; &#125; &#125; return arr; &#125;, /** * 哈希表形式 * @param arr * @returns &#123;Array&#125; */ hash: function (arr) &#123; var i, hash = &#123;&#125;, res = []; //查询hash对象是否存在当前元素(属性) for (i = 0; i &lt; arr.length; i++) &#123; if (!hash[arr[i]]) &#123; res.push(arr[i]); hash[arr[i]] = true; &#125; &#125; return res; &#125;, /** * 借助indexOf方法 * @param arr * @returns &#123;Array&#125; */ indexOf: function (arr) &#123; var i, res = []; //查询空数组里面是否已经存在这个值，不存在则推入 for (i = 0; i &lt; arr.length; i++) &#123; if (res.indexOf(arr[i]) === -1) &#123; res.push(arr[i]); console.log(arr[i]); &#125; &#125; return res; &#125;&#125;; 十三、删除左右空格1234//删除左右空格function trim(str) &#123; return str.replace(/(^\s*)|(\s*$)/g, '');&#125; 十四、判断图片是否加载完1234567functionloadImage1(url,callback)&#123; varimg = newImage(); img.onload = function()&#123; //图片加载完成后执行的操作 &#125; img.src = url;&#125; 十五、图片按某个尺寸等比缩放12345678910function imgRatio(picW,picH,maxWidth,maxHeight)&#123; var Ratio, wRatio = maxWidth / picW, hRatio = maxHeight / picH; if(wRatio &lt; 1 || hRatio &lt; 1)&#123; Ratio = Math.min(wRatio, hRatio); picW = picW * Ratio; picH = picH * Ratio; &#125; &#125; 十六、遍历document.querySelectorAll()方法返回的结果12345678910111213// forEach method, could be shipped as part of an Object Literal/Modulevar forEach = function (array, callback, scope) &#123; for (var i = 0; i &lt; array.length; i++) &#123; callback.call(scope, i, array[i]); // passes back stuff we need &#125;&#125;;// 用法:// optionally change the scope as final parameter too, like ECMA5var myNodeList = document.querySelectorAll('li');forEach(myNodeList, function (index, value) &#123; console.log(index, value); // passes index + value back!&#125;); 十七、内容向上滚动，有停顿1234567891011121314151617181920212223242526272829303132333435363738394041/** * 用于内容向上滚动，有停顿 * @param &#123;object&#125; obj 元素 * @param &#123;number&#125; speed 滚动速度（滚动一个子元素高度的时间，单位毫秒） * @param &#123;number&#125; delay 停顿时间 */function startmarquee(obj, speed, delay) &#123; var t; var p = false; var o = obj; var h; if (!o || o.children.length &lt; 2) return true; o.innerHTML += o.innerHTML; o.scrollTop = 0; h = o.children[0].clientHeight; o.onmouseover = function() &#123; p = true; &#125;; o.onmouseout = function() &#123; p = false; &#125;; function start() &#123; t = setInterval(scrolling, speed / h); if (!p) o.scrollTop += 1; &#125; function scrolling() &#123; if (o.scrollTop % h != 0) &#123; o.scrollTop += 1; if (o.scrollTop &gt;= o.scrollHeight / 2) o.scrollTop = 0; &#125; else &#123; clearInterval(t); setTimeout(start, delay); &#125; &#125; setTimeout(start, delay);&#125; 十八、事件处理兼容写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var eventUtil = &#123; // event兼容 getEvent: function(event) &#123; return event ? event : window.event; &#125;, // target兼容 getTarget: function(event) &#123; return event.target ? event.target : event.srcelem; &#125;, // 添加事件句柄 addHandler: function(elem, type, listener) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type, listener, false); &#125; else if (elem.attachEvent) &#123; elem.attachEvent('on' + type, listener); &#125; else &#123; // 在这里由于.与'on'字符串不能链接，只能用 [] elem['on' + type] = listener; &#125; &#125;, // 移除事件句柄 removeHandler: function(elem, type, listener) &#123; if (elem.removeEventListener) &#123; elem.removeEventListener(type, listener, false); &#125; else if (elem.detachEvent) &#123; elem.detachEvent('on' + type, listener); &#125; else &#123; elem['on' + type] = null; &#125; &#125;, // 添加事件代理 addAgent: function (elem, type, agent, listener) &#123; elem.addEventListener(type, function (e) &#123; if (e.target.matches(agent)) &#123; listener.call(e.target, e); // this 指向 e.target &#125; &#125;); &#125;, // 取消默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 阻止事件冒泡 stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;; 十九、innerText兼容火狐12345678910111213//跨浏览器获取innerTextfunction getInnerText(element)&#123; return (typeof element.textContent == 'string') ? element.textContent : element.innerText;&#125;//跨浏览器设置innerTextfunction setInnerText(element,text)&#123; if(typeof element.textContent == 'string')&#123; element.textContent = text; &#125;else&#123; element.innerText = text; &#125;&#125; 二十、throttle(节流)和debounce(防抖)1、throttle(节流) 应用场景(需要间隔一定时间触发回调来控制函数调用频率) mousemove mousedown/keydown mousemove keyup 监听滚动事件判断是否到页面底部自动加载更多1234567891011121314151617181920212223242526//函数节流（throttle）function throttle(fn, threshhold, scope) &#123; threshhold || (threshhold = 250); var last, timer; return function() &#123; var context = scope || this; var now = +new Date(), args = arguments; if (last &amp;&amp; now - last + threshhold &lt; 0) &#123; clearTimeout(deferTimer); timer = setTimeout(function() &#123; last = now; fn.apply(context, args); &#125;, threshhold); &#125; else &#123; last = now; fn.apply(context, args); &#125; &#125;&#125;//调用方法$('body').on('mousemove', throttle(function(event)&#123; console.log('tick');&#125;, 1000)); 2、debounce(防抖) 应用场景(对于连续的事件响应我们只需要执行一次回调) 每次 resize/scroll 触发统计事件 文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）12345678910111213141516//函数去抖function debounce(fn, delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay) &#125;&#125;//调用方法$('input.username').keypress(debounce(function()&#123; //do the Ajax request&#125;, 250)) 二十一、移动端网络状态判断 123456789101112131415161718192021 //网络状态判断;(function(window)&#123; navigator.onLine ? online() : errorTip(); window.addEventListener("online", online, false); window.addEventListener("offline", offline, false); //重新连接 function online() &#123; //去掉提示 &#125; //连接断开 function offline() &#123; //触发事件 //显示提示 errorTip(); &#125; //错误提示 function errorTip()&#123; alert("网络异常，请稍后再试") &#125;&#125;(window)); 二十二、判断浏览器是否支持 placeholder 123function placeholderSuport() &#123; return "placeholder" in document.createElement("input")&#125; 二十三、判断移动端设备(简单)1234567891011121314151617181920212223242526// 判断设备来源function deviceType()&#123; var ua = navigator.userAgent; var agent = ['Android', 'iPhone', 'Symbian05', 'Windows Phone', 'iPad', 'iPod']; for (var i = 0; i &lt; agent.length; i++) &#123; if (ua.indexOf(agent[i] &gt; 0)) &#123; break; &#125; &#125;&#125;// 判断是否是微信function isWechat()&#123; var ua = navigator.userAgent.toLowerCase(); return ua.match(/MicroMessage/i) == 'micromessager' ? true : false;&#125;// 判断是安卓还是iOSfunction isAndroid()&#123; var ua = navigator.userAgent.toLowerCase(); return /iphone|ipad|ipod/.test(ua) ? false : true;&#125; 二十四、解决不支持console.log报错1var console = console || &#123;log: function() &#123;return;&#125;&#125; 二十五、js类型判断12345678910var a = '';var type = Object.prototype.toString.call(a)// Number: [object Number]// String: [object String]// Array: [object Array]// Object: [object Object]// Boolean: [object Boolean]// Null: [object Null]// Undefined: [object Undefined]// Function: [object Function]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令备忘]]></title>
    <url>%2F2018%2F03%2F04%2Fhexo%2F</url>
    <content type="text"><![CDATA[一、安装npm install -g hexo-cli 二、建站$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 三、生成静态页面hexo generate 四、启动本地服务，进行文章预览调试hexo server 五、每次部署的步骤hexo cleanhexo generatehexo deploy 六、写作hexo new [layout] &lt;title&gt; 查看官网]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glue安装步骤及常用命令]]></title>
    <url>%2F2018%2F03%2F04%2Fglue%2F</url>
    <content type="text"><![CDATA[一、windows安装步骤 安装Python 安装PIL 安装 Python 的 easy_install 添加Python的脚本目录到path 运行如下命令 easy_install glue 二、常用命令 1.快速: glue 源文件夹名称 输出文件夹名称glue source output 2.排序：glue source output --square|vertical|hortizontal|diagonal|vertical-right|horizontal-bottom 3.去掉图片多余的空白glue source output --crop 4.在不同的文件夹下生成css和imgglue source --img=images/compiled --css=css/compiled 5.生成一个测试的htmlglue source output --html 6.更改文件格式glue source output --less 7.展开间距并且不计算为宽高glue source output --10glue source output --&#39;10 20&#39;glue source output --&#39;10 20 30 40&#39; 8.排序glue source output --maxside|width|height|area|filenameglue source output ---maxside|-width|-height|-area|-filename 9.在图像周围填充间距glue source output --10glue source output --10 20glue source output --10 20 30 40 10.图片格式glue source output --png8 11.后台监听glue source output --watch 参考]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>glue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text使用技巧]]></title>
    <url>%2F2017%2F08%2F13%2Fsublime%2F</url>
    <content type="text"><![CDATA[常用快捷键 新建文件：ctrl + n 定义文件类型： ctrl + shift + p, 输入指定的文件类型 复制缩进：ctrl + shift + v 复制一行：ctrl + shift + d 向上插入新行：ctrl + shift + enter 向下插入新行：ctrl + enter 选择一行：ctrl + l 显示/隐藏测导航：ctrl + k + b 打开匹配文件：ctrl + p ,可以输入路径、文件名、#页面匹配、@选择器/函数、:行数 多行游标： 1、ctrl + h 2、ctrl + d（ctrl + k + d: 跳过选中的内容） 3、ctrl + a, ctrl + l 4、shift + 鼠标右键拖动 插件Emment ! + tab 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; ul&gt;.item$*10 + tab 123456789101112&lt;ul&gt; &lt;li class="item1"&gt;&lt;/li&gt; &lt;li class="item2"&gt;&lt;/li&gt; &lt;li class="item3"&gt;&lt;/li&gt; &lt;li class="item4"&gt;&lt;/li&gt; &lt;li class="item5"&gt;&lt;/li&gt; &lt;li class="item6"&gt;&lt;/li&gt; &lt;li class="item7"&gt;&lt;/li&gt; &lt;li class="item8"&gt;&lt;/li&gt; &lt;li class="item9"&gt;&lt;/li&gt; &lt;li class="item10"&gt;&lt;/li&gt;&lt;/ul&gt; h2{text} + tab 1&lt;h2&gt;text&lt;/h2&gt; advanceNewFile 在当前文件下建立新文件 快捷键：ctrl + shift + n]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记]]></title>
    <url>%2F2017%2F08%2F09%2Fes6%2F</url>
    <content type="text"><![CDATA[一、var、let、const1、var: 无论在代码的那个地方声明，都会提升到该函数的开头（变量提升）；栗子：12345for(var i = 0; i &lt; 10; i ++)&#123;&#125;console.log(i); //10 2、let：用法类似于var，但不会变量提升，只在let命令所在的代码块内有效；栗子：12345for(let i = 0; i &lt; 10; i ++)&#123;&#125;console.log(i); //i is not defined 3、const: 声明常量，一旦声明，不可更改（不是变量的值不能改动，而是变量指向的那个内存地址不得改动，见例3），而且常量必须初始化赋值，和let一样，只在声明所在的块级作用域内有效；栗子1：12345// 更改值的情况const PI = 3.1415;console.log(PI);PI = 3;// Assignment to constant variable. 栗子2：123// 未赋值的情况const PI// Missing initializer in const declaration 栗子3：123456// 对象声明const foo = &#123;&#125;;foo.prop = 123;console.log(foo.prop) // 123foo = &#123;&#125; //Assignment to constant variable. 二、解构赋值1、数组的解构赋值 从数组中提取值，按照对应位置，对变量赋值1let [a, b, c] = [1, 2, 3]; 待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript知识点笔记]]></title>
    <url>%2F2017%2F04%2F30%2Fjavascript-base%2F</url>
    <content type="text"><![CDATA[一、break、 continue 和 return 的用法 break：会使运行的程序立刻退出包含在最内层的循环或者退出一个switch语句栗子1：12345for(var i=1;i&lt;=10;i++)&#123; if(i==6) break; document.write(i);&#125;//输出结果：12345 continue：和break相似，不同的是，它不是退出一个循环，而是开始循环的一次新迭代，continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内，在其它地方使用都会引起错误！ return： return语句就是用于指定函数返回的值。return语句只能出现在函数体内，出现在代码中的其他任何地方都会造成语法错误！ 二、instanceof： A instanceof B A 是一个对象，B 是定义类的构造函数，如果 A 是 B 的实例，返回true，（也就是说，如果 A 继承自 B.prototype，返回true；这里的继承可以不是直接继承，如果 A 所继承的对象继承自另一个对象， B 继承自 B.prototype，返回的结果也为true）; constructor 检测对象是否属于某个类 每个javascript函数都自动拥有一个 prototype 属性，这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor，constructor 属性的值是一个函数对象。 新定义的 prototype 不含有 constructor 属性 栗子1：123456var F = function()&#123;&#125;var p = F.prototype; // 这是与F相关联的原型对象var c = p.constructor; // 这是与原型相关联的函数c === F; // true, 对于任意函数F.prototype.constructor == F// 可以看到构造函数的原型中存在预先定义好的constructor 属性，这意味着对象通常继承的constructor均指代它们的构造函数。 栗子2：12var o = new F();o.constructor === F; // true,constructor属性指代这个类 三、hasOwnProperty A.hasOwnProperty(“B”); A 对象，B 属性名，如果 B 是 A 的自有属性 (B 不是 A的继承属性)，则返回true。 栗子1：1234var o = &#123; x: 1 &#125;;o.hasOwnProperty("x"); //true,o 有一个自有属性 xo.hasOwnProperty("y"); // false, o 中不存在属性 yo.hasOwnProperty("toString"); //false, toString 是继承属性 四、in “A” in B A 是属性名（字符串），B 是对象，如果对象的自有属性或继承属性中包含这个属性则返回true 可以区分不存在的属性和存在但值为undefined的属性 栗子1：1234var o = &#123; x: 1 &#125;;"x" in o; // true "x"是 o 的属性"y" in o; // false "y"不是 o 的属性"toString" in o; // true o 继承 toString 属性 五、call() / apply() 改变this的指向； 当一个 对象 没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。 1、call() 参数长度确定时使用 A.call(B, arg1, arg2…) 2、apply() 参数长度不确定时使用 A.call(B, [arg1, arg2…]) 栗子1：（from MDN web docs）调用父构造函数123456789101112131415161718function Product(name, price)&#123; this.name = name; this.price = price;&#125;//===============call==============function Food(name, price)&#123; Product.call(this, name, price); this.category = 'food';&#125;等同于：function Food(name, price)&#123; this.name = name; this.price = price; this.category = 'food';&#125; 栗子2：（from MDN web docs）调用匿名函数12345678910111213141516//===============call==============var animals = [ &#123;species: 'Lion', name:'King'&#125;, &#123;species: 'Whale', name:'Fail'&#125;];for(var i = 0; i &lt; animals.length; i++)&#123; (function(i)&#123; this.print = function()&#123; console.log("#" + i + " " + this.species + ": " + this.name); &#125; this.print(); &#125;).call(animals[i], i)&#125; 栗子3：（from MDN web docs）调用函数并且指定上下文的’this’ 12345678910function greet()&#123; var reply = [this.person, 'Is An Awesome', this.role].join(' '); console.log(reply);&#125;var i = &#123; person: 'Douglas Crockford', role: 'Javascript Developer'&#125;greet.call(i); //Douglas Crockford Is An Awesome Javascript Developer 六、forEach() 遍历数组的函数,传递的函数做为forEach的第一个参数，forEach使用三个参数调用该函数：数组元素，元素的索引，数组本身；【注意：forEach无法在所有元素都传递给调用函数的函数之前终止遍历（即没有像for循环中使用的相应的break语句），如果需要终止循环，必须把forEach()放在一个try块中，并能抛出一个异常，如果forEach()调用函数抛出foreach.break异常，循环会提前终止】 12345data.forEach(function(v, i ,a)&#123;// v:数组元素// i：元素索引// a：数组本身&#125;) 七、cloneNode() 创建节点的拷贝，并返回该副本；克隆所有属性以及它们的值。 语法：var dupNode = node.cloneNode(deep); dupNode：要克隆的节点 node：克隆的新节点 node deep(可选)： true==&gt;克隆所有后代;false只克隆指定的节点 栗子：（from W3School）12345678910111213141516171819202122232425262728//html&lt;ul id="myList1"&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id="myList2"&gt;&lt;li&gt;Water&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// jsvar node=document.getElementById("myList2").lastChild.cloneNode(true);document.getElementById("myList1").appendChild(node);&lt;/script&gt;// 克隆之前//myList1:CoffeeTea//myList2:WaterMilk// 克隆之后//myList1:CoffeeTeaMilk//myList2:WaterMilk 八、cssText 批量修改样式，可以尽量避免页面reflow，提高页面性能 会把原有的cssText清掉, 所以最好使用 累加 的方法； 1234element.style.cssText += "width:20px;height:20px;border:solid 1px red;";// cssText（假如不为空）在IE中最后一个分号会被删掉，可以在前面添加一个分号Element.style.cssText += ‘;width:100px;height:100px;top:100px;left:100px;’ 九、setTimeout() / setInterval() 用来注册在指定的时间之后单次或重复调用的函数 两者都会返回一个值，可以传递给clearTimeout()用于取消这个函数的执行 由于历史原因，第一个参数可以作为字符串传入，如果这么做，那这个字符串会在指定的超时时间或间隔之后进行求值（相当与执行eval()） HTML5 规范还允许传入额外的参数（不支持IE） 1、setTimeout 用来实现一个函数在指定的毫秒数之后运行 2、setInterval 与setTimeout一样，只是这个函数会在指定毫秒数的间隔里重复调用1setInterval(undateClock, 60000);// 每60s调用一个undateClock 栗子：(form JavaScript 权威指南)123456789101112function invoke(f, start, interval, end)&#123; if(!start) start= 0 ; // 默认设置为0 ms if(arguments.length &lt;= 2)&#123; // 单次调用模式 setTimeout(f, start); // start ms 后 单次调用 f() &#125;else &#123; // 多次调用模式 setTimeout(repeat, start); // 在 start 调用repeat() function repeat()&#123; var h = setInterval(f, interval); // 循环调用f() if(end) setTimeout(function()&#123;clearInterval(h)&#125;, end);// 在end ms后停止调用，前提是end已经定义 &#125; &#125;&#125; 十、encodeURIComponent() / decodeURIComponent()1、encodeURIComponent 对统一资源标识符（URI）的组成部分进行编码的方法 转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符栗子：(from MDN web docs)123456789101112131415161718var fileName = 'my file(2).txt';var header = "Content-Disposition: attachment; filename*=UTF-8''" + encodeRFC5987ValueChars(fileName);console.log(header); // 输出 "Content-Disposition: attachment; filename*=UTF-8''my%20file%282%29.txt"function encodeRFC5987ValueChars (str) &#123; return encodeURIComponent(str). // 注意，仅管 RFC3986 保留 "!"，但 RFC5987 并没有 // 所以我们并不需要过滤它 replace(/['()]/g, escape). // i.e., %27 %28 %29 replace(/\*/g, '%2A'). // 下面的并不是 RFC5987 中 URI 编码必须的 // 所以对于 |`^ 这3个字符我们可以稍稍提高一点可读性 replace(/%(?:7C|60|5E)/g, unescape);&#125; 2、decodeURIComponent 用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI） 将已编码 URI 中所有能识别的转义序列转换成原字符栗子：(from MDN web docs)12decodeURIComponent("JavaScript_%D1%88%D0%B5%D0%BB%D0%BB%D1%8B");// "JavaScript_шеллы" 十一、getBoundingClientRect() 返回元素在视口坐标中的位置，返回一个有left、right、top、bottom属性的对象。 left和top属性表示元素的左上角的X和Y坐标，right和bottom属性表示元素右下角的X和Y坐标 在很多浏览器中，还返回 width和height，在是在ie中未实现 不是实时的，在用户滚动或改变浏览器窗口大小时不会更新 栗子：（from JavaScript权威指南）1234567891011121314151617181920212223var box = e.getBoundingClientRect(); //获得在视口坐标中的位置var offsets = getScrollOffsets();var x = box.left + offset.x;var y = box.top + offset.yvar w = box.width || (box.right - box.left);var h = box.height || (box.bottom - box.top);// 滚动条位置function getScrollOffsets(w)&#123; w = w || window; // 除ie8- 版本，其他浏览器都能用 if(w.pageXOffset != null) return &#123;x: w.pageXOffset, y: w.pageYOffset&#125;; // 对标准模式下的浏览器 var d = w.document; if(document.compatMode == "CSS1Compat")&#123; return &#123;x: d.documentElement.scrollLeft, y： d.documentElement.scrollTop&#125;; &#125; // 对怪异模式下的浏览器 return &#123;x: d.body.scrollLeft, y: d.body.scrollTop&#125;;&#125; 十二、createDocumentFragment 作为其他节点的一个临时容器，是独立的，通常用在 创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树栗子：（from JavaScript权威指南）123456789101112// 倒叙排列节点n的子节点function reverse(n)&#123; // 创建一个DocumentFragment作为临时容器 var f = document.createDocumentFragment(); // 从后至前循环子节点，将每一个子节点移动到文档片段中 // 注意：给f添加一个节点，改节点自动的会从n中删除 while(n.lastChild) f.appendChild(n.lastChild); // 把f 的所有子节点一次性全部移回n中 n.appendChild(f);&#125; 十三、defaultView / getComputedStyle()1、defaultView 在浏览器中，该属性返回当前 document 对象所关联的 window 对象，如果没有，会返回 null 只读 IE 9 以下版本不支持 使用方式： document.defaultView 2、getComputedStyle 是一个可以获取当前元素所有最终使用的CSS属性值，返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读 语法：window.getComputedStyle(element, [pseudoElt]); element:用于获取计算样式的Element pseudoElt: 可选，指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。 栗子1：（from MDN web docs）12345let elem1 = document.getElementById("elemId");let style = window.getComputedStyle(elem1, null);// 它等价于// let style = document.defaultView.getComputedStyle(elem1, null); 栗子2：(from MDN web docs）12345678910111213141516171819202122&lt;style&gt; #elem-container&#123; position: absolute; left: 100px; top: 200px; height: 100px; &#125;&lt;/style&gt;&lt;div id="elem-container"&gt;dummy&lt;/div&gt;&lt;div id="output"&gt;&lt;/div&gt;&lt;script&gt; function getTheStyle()&#123; let elem = document.getElementById("elem-container"); //getPropertyValue()返回一个DOMString含有一个指定的CSS属性的值 let theCSSprop = window.getComputedStyle(elem,null).getPropertyValue("height"); document.getElementById("output").innerHTML = theCSSprop; &#125; getTheStyle();&lt;/script&gt; 待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html基础知识]]></title>
    <url>%2F2017%2F04%2F16%2Fbase-html%2F</url>
    <content type="text"><![CDATA[一、Doctype-&lt;!DOCTYPE&gt; 声明必须位于 HTML5 文档中的第一行，也就是位于 标签之前。该标签告知浏览器文档所使用的 HTML 规范。doctype 声明不属于 HTML 标签；它是一条指令，告诉浏览器编写页面所用的标记的版本。在所有 HTML 文档中规定 doctype 是非常重要的，这样浏览器就能了解预期的文档类型。HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。而 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行。）。 二、常用元素1、块级元素12345678910111213141516171819div - 常用块级容器，也是css layout的主要标签p - 段落ul - 无序列表dl - 定义列表ol - 排序表单table - 表格h1~h6 - 标题form - 交互表单pre - 格式化文本address - 地址blockquote - 块引用center - 居中对齐块dir - 目录列表fieldset - form控制组hr - 水平分割线menu - 菜单列表noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容）noscript - 可选脚本内容（对于不支持script的浏览器显示此内容） 2、行内元素123456789101112131415161718192021a - 锚点span - 常用内联容器，定义文本内区块em - 强调i - 斜体img - 图片label - 表格标签input - 输入框textarea - 多行文本输入框select - 项目选择abbr - 缩写acronym - 首字b - 粗体br - 换行strike - 中划线u - 下划线strong - 粗体强调sub - 下标sup - 上标code - 计算机代码(引用源码的时候需要)samp - 定义范例计算机代码 3、空元素123&lt;br&gt; - 换行&lt;hr&gt; - 水平分割线&lt;img&gt; - 图片 三、link和@import引入样式的区别 1、link属于XHTML标签，除了可以加载css外，还可以定义RSS、rel连接属性等；@import 是css提供的一种方式，只能加CSS。 2、加载顺序不同:当一个页面被加载的时候，link引用的css会同时被加载，而@import引用的css会等到页面全部被下载完再被加载，所有有时候浏览@import加载css的页面时开始会没有样式（闪烁），网速慢的时候很明显。 3、兼容性:link无兼容问题，@import只有在ie5以上的才能识别。 4、使用dom控制样式时的差别：当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。 5、@import可以在css中再次引入其他样式表。 三、浏览器内核 负责对网页语法的解释并渲染网页 常见的浏览器内核 Trident：IE浏览器使用的内核 Gecko：Netscape6开始采用的内核，火来的Mozilla FireFox也采用了该内核 Presto:目前Opera采用的内核 Webkit：苹果公司自己的内核 四、html51、新元素123内容元素：article、footer、header、nav、section表单控件：calender、date、time、email、url、search控件元素：webworker、wesockt、Geolocation 2、移除的元素12显现层元素：basefont、big、center、font、s、strike、tt、u性能较差元素：frame、framest、noframes 3.兼容 IE8/IE7/IE6支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签 使用html5shim框架 4、区分HTML和HTML5 DOCTYPE声明方式是区分HTML和HTML5标志的一个重要因素，还可以根据新增的结构、功能元素来加以区分 五、理解HTML语义化 语义化有利于SEO，有利于搜索引擎爬虫更好的理解网页，从而获取更多的有效信息，提升网页的权重。 在没有css的时候能够清晰的看出网页的节骨，增强可读性。 便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力 支持多端设备的浏览器渲染。 六、html5离线存储 将一些资源文件保存在本地，这样后续的页面重新加载将使用本地资源文件，在离线情况下可以继续访问web应用，同时通过一定的手法(更新相关文件或者使用相关API)，可以更新、删除离线存储等操作 基本流程：当第一次正确配置app cache后，当我们能再次访问该应用时，浏览器会首先检查manifest文件是否有变动。如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回。 七、cookies,sessionStorage和localStorage 共同点：都保存在浏览器端，且同源 区别： cookie： （1）始终在同源的http请求中携带（及时不需要），即cookie在浏览器和服务器间来回传递 ； （2）有路径的概念，可以限制cookie只属于某个路径下； （3）数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识； （4）只在设置的cookie过期时间之前一直有效，即窗口或浏览器关闭； （5）在所有同源窗口中都是共享的。 sessionStorage: （1）只做本地保存，不会自动把数据发给服务器 （2）数据可以达到5M或更多 （3）仅当前浏览器窗口关闭前有效 （4）在不同的浏览器窗口中不同享，即使是同一个页面 localStorage: （1）只做本地保存，不会自动把数据发给服务器 （2）数据可以达到5M或更多 （3）始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据； （4）在所有同源窗口中都共享 八、iframe的优缺点 优点： （1）iframe能够原封不动的把嵌入的网页展现出来。 （2）如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 （3）网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 （4）如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点： （1）会产生很多页面，不容易管理。 （2）iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 （3）代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。 （4）很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 （5）iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 九、label的作用 label 标签为 input 元素定义标注（标记）。 label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 Label 中有两个属性是非常有用的,一个是FOR、另外一个就是ACCESSKEY了。 FOR属性 :表示Label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点。 ACCESSKEY属性：功能：表示访问Label标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。 十、html5的form如何关闭自动完成功能1&lt;form autocomplete="on/off"&gt; on 默认。规定启用自动完成功能。 off 规定禁用自动完成功能。 十一、实现一个圆形可点击区域 map+area 或者 svg; border-radius; 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等; 二、实现不使用border画出1px高的线，在不同浏览器的Quirksmode和CSSCompat下能保持一致1&lt;div style="height:1px;overflow:hidden;background:black"&gt;&lt;/div&gt; 十三、title和h1、b和strong、i和em的区别 title标签是用来描述这个页面的主题的，是一个网页权重的最高点。但title标签并不出现在文章的正文中。 h1标签一般出现在文章的正文中，是展示给访问者的文章的标题。所以说这两个标签不仅不冲突的，而是合作的关系。 一篇文章既要有title又要有h1标签，既突出了文章的主题，又突出了标题和关键字，达到双重优化网站的效果。一般会把title和h1标签的内容写成一样，而且一般情况下一篇文章最好只用一个h1标签，过多的h1标签反而会让搜索引擎迷糊，认不清文章的主题。 b与strong的区别、i与em的区别 b标签和strong标签给我们的主观感受都是加粗，但对搜索引擎来说b标签和普通的文字并没有什么区别，而strong标签却是起强调作用的。也就是说如果你想让搜索引擎认为你的某句话很重要时那就用strong标签。如果只是想让用户看到加粗的效果，那就用b标签。 em标签也是针对搜索引擎来起作用的，i标签只是让用户看到展示的是斜体。 参考 未完待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习]]></title>
    <url>%2F2017%2F04%2F04%2Fvuejs%2F</url>
    <content type="text"><![CDATA[一、Vue.js组件的重要选项1、data: vue对象的数据2、methods: vue对象的方法3、watch: 设置了对象监听的方法 1234567891011121314151617181920&lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt;&lt;script&gt;new Vue(&#123; data: &#123; a: 1, b: [] &#125;, methods: &#123; doSometh: function()&#123; console.log(this.a) &#125; &#125;, watch: &#123; 'a': function(val, oldVal)&#123; console.log(val, oldVal) &#125; &#125;&#125;)&lt;/script&gt; 二、模板指令——html和vue对象的粘合剂1、数据渲染：1v-text、v-html、 &#123;&#123; &#125;&#125; 1234567891011&lt;p&gt;&#123;&#123; a &#125;&#125;&lt;/p&gt;&lt;p v-text="a"&gt;&lt;/p&gt;&lt;p v-html="a"&gt;&lt;/p&gt;&lt;script&gt;new Vue(&#123; data: [ a: 1, b: [] ]&#125;)&lt;script&gt; 2、控制模块隐藏： v-if、v-show12345678910&lt;p v-if="isShow"&gt;&lt;/p&gt;&lt;p v-show="isShow"&gt;&lt;/p&gt;&lt;script&gt; new Vue(&#123; data: &#123; isShow: true &#125;&#125;)&lt;/script&gt; 3、渲染循环列表： v-for1234567891011121314151617181920&lt;ul&gt; &lt;li v-for='item in items'&gt; &lt;p v-text='item.label'&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;...data: &#123; items: [ &#123; label: 'apple' &#125;, &#123; label: 'banana' &#125; ]&#125;...&lt;/script&gt; 4、事件绑定： v-on123456789&lt;button v-on:click="doThis"&gt;&lt;/button&gt;&lt;button @click="doThis"&gt;&lt;/button&gt;&lt;script&gt;...nethods: &#123; doThis: function(someThing)&#123;&#125;&#125;...&lt;/script&gt; 5、属性绑定： v-bind123456&lt;img v-bind:src="" alt=""&gt; //字符串&lt;img :src="" alt=""&gt;&lt;div ：class="&#123; red: isRed &#125;"&gt;&lt;/div&gt; //布尔值&lt;div ：class="[classA, classB]"&gt;&lt;/div&gt; //&lt;div ：class="[classA, &#123;classB: isB, classC： isC&#125;]"&gt;&lt;/div&gt; 未完待续。。。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass学习笔记]]></title>
    <url>%2F2017%2F03%2F27%2Fsass%2F</url>
    <content type="text"><![CDATA[一、常用命令 项目中常用：sass --watch sass:css --style compact 格式转换sass-convert style.sass style.scss 运行sasssass input.css output.css 监视sass文件，每次更新时，自动编译成csssass --watch input.scss: output.css 监视整个文件夹sass --watch app/sass:public/stylesheets 更多命令行sass --help 紧凑输出方式 campactsass --watch test.scss:test.css --style compact 压缩输出方式 campactsass --watch test.scss:test.css --style compressed 二、基本用法1、变量 使用$开头 1234$blue : #1875e7;div&#123; color: $blue;&#125; 如果变量需要镶嵌在字符串中，就必须需要写在#{}之中 1234$side: left;.rounded &#123; border-#&#123;$side&#125;-radius: 5px;&#125; 2、计算功能 例如123456$var: 500px;body&#123; margin: (14px/2); top:50px + 100px; right:$var * 10%&#125; 3、嵌套 标签嵌套 12345div&#123; h1&#123; color:red; &#125;&#125; 属性嵌套 12345p&#123; border:&#123; color:red; &#125;&#125; 伪类 12345a &#123; &amp;:hover&#123; color:#ffb3ff; &#125;&#125; 4、注释 会保留到编译后的文件/* */ 只保留在sass源文件中，编译后被省略// 主要注释，即使是压缩模式编译，也会保留这行注释，通常用作声明版权信息123/*! 重要注释*/ 三、代码重用4、继承 例如12345678.class1&#123; border: 1px solid #ddd;&#125;.class2&#123; @extend .class1; font-size: 120%;&#125; 5、Mixin 可以重用的代码块 12345678@mixin left($value: 10px)&#123; float: left; margin-right: $value;&#125;div&#123; @include left;&#125; 可以指定参数和缺省值 12345678910111213@mixin rounded($vert, $horz, $radius: 10px)&#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius;&#125;#navbar li&#123; @include rounded(top, left);&#125;#footer&#123; @include rounded(top, left, 5px);&#125; 6、颜色函数1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080complement(#cc3) // #33c 7、插入文件 @import命令，用来插入外部文件。 1 @import "path/filename.scss"; 如果插入的是.css文件，则等同于css的import命令。 1 @import "foo.css"; 四、高级用法1、条件语句 例1 123456789p &#123; @if 1 + 1 == 2 &#123; border:1px solid #eee; &#125; @if 5 &lt; 3 &#123; border:2px dotted #eee; &#125;&#125;等同于：p &#123; border: 1px solid #eee; &#125; 例2 12345678910p&#123; @if lightness($color) &gt; 30% &#123; background-color: #000; &#125; @else &#123; background-color: #fff; &#125;&#125;等同于：p &#123; background-color: #000; &#125; 2、循环语句 for循环 12345678910111213141516@for $i from 1 to 10&#123; .border-#&#123;$i&#125;&#123; border: #&#123;$i&#125;px solid blue; &#125;&#125;等同于：.border-1 &#123;border: 1px solid blue; &#125;.border-2 &#123;border: 2px solid blue; &#125;.border-3 &#123;border: 3px solid blue; &#125;.border-4 &#123;border: 4px solid blue; &#125;.border-5 &#123;border: 5px solid blue; &#125;.border-6 &#123;border: 6px solid blue; &#125;.border-7 &#123;border: 7px solid blue; &#125;.border-8 &#123;border: 8px solid blue; &#125;.border-9 &#123;border: 9px solid blue; &#125; while循环 12345678910111213$i: 6;@while $i &gt; 0&#123; .item-#&#123;$i&#125;&#123; width: 2em * $i; &#125; $i: $i - 2;&#125;等同于：.item-6 &#123;width: 12em; &#125;.item-4 &#123;width: 8em; &#125;.item-2 &#123;width: 4em; &#125; each 1234567891011@each $member in a,b,c,d&#123; .#&#123;$member&#125; &#123; background-image:url("/image/#&#123;$member&#125;.jpg"); &#125;&#125;等同于：.a &#123;background-image: url("/image/a.jpg"); &#125;.b &#123;background-image: url("/image/b.jpg"); &#125;.c &#123;background-image: url("/image/c.jpg"); &#125;.d &#123;background-image: url("/image/d.jpg"); &#125; 3、自定义函数 例如：12345678910@function double($n)&#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125;等同于：#sidebar &#123; width: 10px; &#125; ps: 参考,安装,调试,编译]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
</search>
